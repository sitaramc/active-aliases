### other ideas from http://grml.org/zsh/zsh-lovers.html
###
### alias -g CA='|& cat -A'
###     ... similarly for less, egrep, and variants ...
### alias -g NUL="> /dev/null 2>&1"
### alias -g NE="2> /dev/null"
###     ... etc ...
###
### but maybe we'll be happier with prefix form:
###     CA <command>
### or at least
###     NO <command>
###     NE <command>
###     NOE <command>
### other examples
###     TL
###     T20
###     LS

# syntax
# aliasname <TAB> pattern <TAB> replacement
# %% in pattern is (.+); % is (\S+)
# %<digits> in repl is corresponding paren
# rules are matched in sequence

# ---------- ALL ----------
# 'c' field eq 'ALL' means apply this transform to ANY incoming command

# these must come *before* all other transformations, so they are in the
# shipped rc file (the one in the same directory as the binary).

# make normal commands go through __ by prefixing with a "." (bloody zsh takes
# over the _-prefixed versions)
ALL	\.%	%1

ALL	%% LF	%1 ./LF1.
ALL	%% LF(\D\S+)	%1 ./LF1%2
ALL	%% LF(\d)	%1 ./LF%2.
ALL	%% LF(\d\S+)	%1 ./LF%2

ALL	%% %/LF	%1 %2/LF1.
ALL	%% %/LF(\D\S+)	%1 %2/LF1%3
ALL	%% %/LF(\d)	%1 %2/LF%3.

ALL	%% %/LF(\d)(\S+)	%1 %2/`cd %2 ;ls -Atrc|grep %4|tail -%3|head -1`	print STDERR "+%2/" . `cd %2 ;ls -Atrc|grep %4|tail -%3|head -1`

ALL	%% LL	%1 ./LL1
ALL	%% LL(\d)	%1 ./LL%2
ALL	%% (\D\S*)/LL	%1 %2/LL1
ALL	%% %/LL(\d)	%1 %2/`cd %2 ;ls -A|tail -%3|head -1`	print STDERR "+%2/" . `cd %2 ;ls -A|tail -%3|head -1`

ALL	%% Ym-%	%1 `date +%Y-%m-`%2
ALL	%% Ymd-%	%1 `date +%Y-%m-%d-`%2

# ---------- 'dm' (daemonise) ----------
dm	dm %	dm xdg-open %1	-f "%1" and not -x "%1"
dm	dm %%	( ( sleep 2; nice %1 >/dev/null 2>&1 ) & )
dm	dm (\d) %%	( ( notify-send -t "%1"000 "%2" "`nice %2 2>&1`" ) & )

# ---------- task ----------
tl	tl	t list
tdl	tdl	t d list
t	t d %%	t +DIR +$(basename $PWD) %1
t	t % d	t %1 +DIR +$(basename $PWD)
t	t help$	perl -ne 'next unless /##/; print "\t" unless /^##/; print' ~/.taskrc
# the "." shortcut lets you operate on the latest non-completed/non-deleted task
t	t \.	t `task _ids | tail -1`
# unfortunately you can't do the same for "all" tasks (i.e., including
# completed and deleted tasks), so I have a special report called "U" that
# contains just id, UUID, desc.count.  We use that to get the uuid of the last
# "all" task that matches the filter supplied and do something on it.
t	t u %% -- %%	t `task rc.defaultwidth:0 rc.verbose:nothing U %1 | cut -c4-39 | tail -1` %2
# ...or just take the last one regardless
t	t u -- %%	t `task rc.defaultwidth:0 rc.verbose:nothing U | cut -c4-39 | tail -1` %1
t	t (\d+)$	task %1 info
t	t %% (\d+)$	task %1 limit:%2
t	t ([0-9a-f]{8})$	task `task _uuids | grep %1` info
t	t ([0-9a-f]{8}) %%	t `task _uuids | grep %1` %2
t	t %% ::%	task %1 due:%2 wait:%2
t	t	task

# this is here as a sample; it won't be any use unless you installed 'ew', but
# you can do this with grep as well if you wish
# ---------- ew ----------
# this one makes it hard to grep for single digits; oh well...
ew	ew ([1-9])	ew -n -%1
ew	ew ([lnv])	ew -%1

# some of these require 'sf' (which is a wrapper over 'find').  As such, they
# won't be generally useful.  Ditto with the vim command 'Grep'.  Overall,
# this is useless for others but shows how canonicalisation happens.
# ---------- vim ----------
# which
vw	vw %%	vim `which %1`
# mru (from viminfo)
vm	vm %%	vv -m %1
# dir
vd	vd %%	vv %1
# repo
vr	vr %%	vv -r %1
# line
vg	vg i w %%	vg -i -w %1
vg	vg iw %%	vg -i -w %1
vg	vg w i %%	vg -i -w %1
vg	vg wi %%	vg -i -w %1
vg	vg i %%	vg -i %1
vg	vg w %%	vg -w %1
vg	vg %%	vim -c 'Grep %1'

# ---------- chmod ----------
# most common uses of chmod
ch	ch r	chmod -R go+rX
ch	ch w	chmod u+w
ch	ch x	chmod +x

# ---------- ltrc|ew|tail ----------
# 2 args; note that we don't cater to N > 9 here
lf	lf (\d) %	lf %2 %1
lf	lf % (\d)$	lf %1 . -%2	-d "%1"
lf	lf % (\d)$	lf . %1 -%2
lf	lf % %$	lf %2 %1 -10	not -d "%1"
lf	lf % %$	lf %1 %2 -10
# 1 arg
lf	lf %$	lf %1 . -10	-d "%1"
lf	lf %$	lf . %1 -10
# no args
lf	lf$	lf . . -10
# canonical form 1
lf	lf % \. -%	ls -Altrc "%1" | tail -%2
# canonical form 2
lf	lf % % -%	ls -Altrc "%1" | grep -i %2 | tail -%3

# ---------- tig ----------
ts	ts	tg s
tg	tg b	tg --boundary
tg	tg s	tg status
tg	tg	tg CDRR
tg	tg CDRR	cd `git rev-parse --show-toplevel` ; tig

# ---------- git ----------
glg	glg$	glg 5
glg	glg (\d+)$	git lg -%1 | less -R -F

# many of these are likely to be specific to my environment
# ---------- misc ----------
# save	save %%	7z a -tzip -mem=AES256 -r -p /tmp/save.`date -I`.$$ %1 ; rsync -vP /tmp/save.`date -I`.$$ atc:t
t1	t1 %	TSH_ERREXIT=1 TSH_VERBOSE=1 HARNESS_ACTIVE=1 "%1"
t4	t4 %	TSH_ERREXIT=1 TSH_VERBOSE=4 HARNESS_ACTIVE=1 "%1"

# blow(fish pipes (blowpipes??)
bf	bf e	openssl bf -salt
bf	bf d	openssl bf -d

# vim: ts=16:
