### other ideas from http://grml.org/zsh/zsh-lovers.html
###
### alias -g CA='|& cat -A'
###     ... similarly for less, egrep, and variants ...
### alias -g NUL="> /dev/null 2>&1"
### alias -g NE="2> /dev/null"
###     ... etc ...
###
### but maybe we'll be happier with prefix form:
###     CA <command>
### or at least
###     NO <command>
###     NE <command>
###     NOE <command>
### other examples
###     TL
###     T20
###     LS

# syntax
# aliasname <TAB> pattern <TAB> replacement(shell) [ <TAB> condition(perl) ]
# %% in pattern is (.+); % is (\S+)
# %<digits> in repl is corresponding paren
# rules are matched in sequence, condition is eval-ed in same perl process

# some of these require 'sf' (which is a wrapper over 'find').  As such, they
# won't be generally useful.  Ditto with the vim command 'Grep'.  Overall,
# this is useless for others but shows how canonicalisation happens.

# ---------- ALL ----------
# 'c' field eq 'ALL' means apply this transform to ANY incoming command

# these must come *before* all other transformations, so they are in the
# shipped rc file (the one in the same directory as the binary).

# make normal commands go through __ by prefixing with a "." (bloody zsh takes
# over the _-prefixed versions)

## *:(dir/)?LF[1-9]?, (dir/)?LL[1-9]?, Ym-..., Ymd-...
ALL	\.%	%1

ALL	%% LF	%1 ./LF1.
ALL	%% LF(\D\S+)	%1 ./LF1%2
ALL	%% LF(\d)	%1 ./LF%2.
ALL	%% LF(\d\S+)	%1 ./LF%2

ALL	%% %/LF	%1 %2/LF1.
ALL	%% %/LF(\D\S+)	%1 %2/LF1%3
ALL	%% %/LF(\d)	%1 %2/LF%3.

ALL	%% %/LF(\d)(\S+)	\
                                %1 %2/`cd %2 ;ls -Atrc|grep %4|tail -%3|head -1`	\
                                                print STDERR "+%2/" . `cd %2 ;ls -Atrc|grep %4|tail -%3|head -1`

ALL	%% LL	%1 ./LL1
ALL	%% LL(\d)	%1 ./LL%2
ALL	%% (\D\S*)/LL	%1 %2/LL1
ALL	%% %/LL(\d)	%1 %2/`cd %2 ;ls -A|tail -%3|head -1`	print STDERR "+%2/" . `cd %2 ;ls -A|tail -%3|head -1`

ALL	%% Ym-%	%1 `date +%Y-%m-`%2
ALL	%% Ymd-%	%1 `date +%Y-%m-%d-`%2

# ---- process control: dm, slow, nolang, DO

## dm:daemonise; dm (sleep time)? file|command
dm	dm %	dm xdg-open %1	-f "%1" and not -x "%1"
dm	dm %%	( ( sleep 1; nice %1 >/dev/null 2>&1 ) & )
dm	dm (\d) %%	( ( notify-send -t "%1"000 "%2" "`nice %2 2>&1`" ) & )
## slow:slow (uN|dN|uN dN)
slow	slow u(\d+) d(\d+)	_slow -u %1 -d %2
slow	slow u(\d+)	_slow -u %1
slow	slow d(\d+)	_slow -d %1
slow	slow	@echo usage: slow uN|dN|uN dN
_slow	_slow	trickle -s
## nolang:delete LANG and LC_* then run
nolang	nolang %	%1	delete $ENV{LANG}; \
                                                map { delete $ENV{$_} } \
                                                    grep /^LC_/, keys %ENV; \
                                                1
## DO:DO [seconds] command args
DO	DO (\d+)	_DO %1
DO	DO	_DO 1
_DO	_DO % %%	@while :; do %2; sleep %1; done

# ---- vim: vw/vm/vd/vr/vg

## vw:vim which
vw	vw %%	$EDITOR `which %1`	$ENV{EDITOR}
## vm:vim mru (from viminfo)
vm	vm %%	vv -m %1
## vd:vim file in dir
vd	vd %%	vv %1
## vr:vim file in repo
vr	vr %%	vv -r %1
## vg:vim Grep; vg [iw]* ==> -i/-w
vg	vg i w %%	vg -i -w %1
vg	vg iw %%	vg -i -w %1
vg	vg w i %%	vg -i -w %1
vg	vg wi %%	vg -i -w %1
vg	vg i %%	vg -i %1
vg	vg w %%	vg -w %1
vg	vg %%	$EDITOR -c 'Grep %1'	$ENV{EDITOR}

# ---- text handling: mgrep, InPlace, field, hdt, hd

## mgrep:mgrep word list; grep multiple words, prefix with "-" to exclude.  Last word is colored
mgrep	mgrep -i	mgrep	$ENV{MG_I)="-i"
mgrep	mgrep % %%	mgrep %1 | __ mgrep %2
mgrep	mgrep -%	@grep $MG_I -v %1
mgrep	mgrep %	@grep $MG_I --color %1

## InPlace:(NO WARNINGS, NO SECOND CHANCES) frompatt topatt filelist...
InPlace	InPlace -i % %	perl -w -0777 -pi -e "s(%1)(%2)gi"
InPlace	InPlace % %	perl -w -0777 -pi -e "s(%1)(%2)g"

## field:|field N
field	field (\d+)	awk '{print $%1}'
## hdt:|hdt
hdt	hdt	perl -pe 's/^\d{5,}(\.\d+)?/localtime $&/e'
## hd:|hd; hexdump using od options
hd	hd	od -Ax -tx1z -v

# ---- file handing: ch, lf

## ch:chmod; ch r ==> -R go+rx, w ==> u+w, x ==> +x
ch	ch r	chmod -R go+rX
ch	ch w	chmod u+w
ch	ch x	chmod +x

# lf: <dir> <patt> <count>
## lf:latest files, lf dir? patt? count? (only one or all 3; defaults . . 10)
lf	lf$	lf . . -10
lf	lf (\d+)$	lf . . -%1
lf	lf %$	lf %1 . -10	-d "%1"
lf	lf %$	lf . %1 -10
# canonical form 1
lf	lf % \. -%	ls -Altrc "%1" | tail -%2
# canonical form 2
lf	lf % % -%	ls -Altrc "%1" | grep -i %2 | tail -%3

# ---- git (--, ts/tg, glg, t1/t4)

## --: git checkout - (sweet!)
--	--	git co -

## ts:tig s (status)
## tg:tig, tg ==> tig, tg b ==> tig --boundary (will cd to repo root dir first)
ts	ts	tg s
tg	tg b	tg --boundary
tg	tg s	tg status
tg	tg	tg CDRR
tg	tg CDRR	cd `git rev-parse --show-toplevel` ; tig

## glg:glg \d* ==> git lg -n(5)
glg	glg$	glg 5
glg	glg (\d+)$	git lg -%1 | less -R -F

## t1
t1	t1 %	TSH_ERREXIT=1 TSH_VERBOSE=1 HARNESS_ACTIVE=1 "%1"
## t4
t4	t4 %	TSH_ERREXIT=1 TSH_VERBOSE=4 HARNESS_ACTIVE=1 "%1"

# ---- system (qf, qd, gu, fssum, flsum)

## qf:rpm -qf (args or STDIN)
qf	qf$	xargs rpm -qf
qf	qf	rpm -qf

## qd:qd rpmname
qd	qd %	less `rpm -qd %1 | grep -v man.man`; man `rpm -qd %1 | grep man.man`

## gu:gaf cycle && gaf pall
gu	gu	gaf cycle && gaf pall

## flsum:|flsum (\d+)?; file list summary, keep upto NUM slashes and summarise
flsum	flsum$	flsum 2
flsum	flsum %$	perl -pe "s/(([^\/]+\/){%1}).*/\$1/" | sort | uniq -c

## fssum:fssum [dir], print #dirs, #files, size dist
fssum	fssum %	fssum	chdir $1
fssum	fssum	@du -sm .; \
                                echo -e `find . -type d | wc -l `'\tdirectories'; \
                                echo -e `find . -type f | wc -l `'\tfiles'; \
                                echo '  FILES MB      CUM MB'; \
                                find . -type f -print0 | \
                                    xargs -0 du -sm | cut -f1 | \
                                    sort | uniq -c | sort -k 2nr | \
                                perl -lpe '($a,$b)=split;$tot+=$a*$b;$_.="\t$tot"'

# ---- sec (bf, PWGEN, crypdf)

## bf:bf e|d|ea|da
bf	bf ea	bf e -a
bf	bf da	bf d -a
bf	bf e	openssl bf -salt
bf	bf d	openssl bf -d
# TODO: inplace enc/dec

## crypdf:crypdf d|e infile outfile [other flags for enc], (password will be asked on STDIN)
# note: okular as of 2015-06-06 does not read 256 bit encrypted files so no point
crypdf	crypdf d % %	qpdf --empty --pages %1 --password=`cat` -- %2

crypdf	crypdf e	crypdf e	chomp($ENV{CP_PW}=<STDIN>); \
                                                $ENV{CP_FLAGS}="128 --use-aes=y";\
                                                1

crypdf	crypdf e % % %%$	\
                                crypdf e %1 %2	$ENV{CP_FLAGS}.=" %3"; 1

crypdf	crypdf e % %$	qpdf --empty --pages %1 -- \
                                    --encrypt $CP_PW $CP_PW $CP_FLAGS -- \
                                    %2

## PWGEN
PWGEN	PWGEN	cat /usr/share/dict/words|egrep '^.{3,6}$'|shuf 2>/dev/null|head -1000|egrep '^[a-z]*$'|column|head

# ---- misc (dot)

## dot:dot gv-file [png-file] (defaults to ~/junk.png)
dot	dot %$	dot %1 ~/junk.png
dot	dot % %$	/usr/bin/dot -Tpng %1 -o %2; display %2 &

# vim: ts=16:
