### other ideas from http://grml.org/zsh/zsh-lovers.html
###
### alias -g CA='|& cat -A'
###     ... similarly for less, egrep, and variants ...
### alias -g NUL="> /dev/null 2>&1"
### alias -g NE="2> /dev/null"
###     ... etc ...
###
### but maybe we'll be happier with prefix form:
###     CA <command>
### or at least
###     NO <command>
###     NE <command>
###     NOE <command>
### other examples
###     TL
###     T20
###     LS

# syntax
# aliasname <TAB> pattern <TAB> replacement(shell) [ <TAB> condition(perl) ]
# %% in pattern is (.+); % is (\S+)
# %<digits> in repl is corresponding paren
# rules are matched in sequence, condition is eval-ed in same perl process

# some of these require 'sf' (which is a wrapper over 'find').  As such, they
# won't be generally useful.  Ditto with the vim command 'Grep'.  Overall,
# this is useless for others but shows how canonicalisation happens.

# ---------- ALL ----------
# these must come *before* all other transformations, so they are in the
# shipped rc file (the one in the same directory as the binary).

# make normal commands go through __ by prefixing with a "." (bloody zsh takes
# over the _-prefixed versions)

## *:(dir/)?LF[1-9]?, (dir/)?LL[1-9]?, Ym-..., Ymd-...
\.%	%1

%% LF	%1 ./LF1.
%% LF(\D\S+)	%1 ./LF1%2
%% LF(\d)	%1 ./LF%2.
%% LF(\d\S+)	%1 ./LF%2

%% %/LF	%1 %2/LF1.
%% %/LF(\D\S+)	%1 %2/LF1%3
%% %/LF(\d)	%1 %2/LF%3.

%% %/LF(\d)(\S+)	\
                                %1 %2/`cd %2 ;ls -Atrc|grep %4|tail -%3|head -1`	\
                                                print STDERR "+%2/" . `cd %2 ;ls -Atrc|grep %4|tail -%3|head -1`

%% LL	%1 ./LL1
%% LL(\d)	%1 ./LL%2
%% (\D\S*)/LL	%1 %2/LL1
%% %/LL(\d)	%1 %2/`cd %2 ;ls -A|tail -%3|head -1`	print STDERR "+%2/" . `cd %2 ;ls -A|tail -%3|head -1`

%% Ym-%	%1 `date +%Y-%m-`%2
%% Ymd-%	%1 `date +%Y-%m-%d-`%2

# ---- process control: dm, slow, nolang, DO

## dm:daemonise; dm (sleep time)? file|command
dm %	dm xdg-open %1	-f "%1" and not -x "%1"
dm %%	( ( sleep 1; nice %1 >/dev/null 2>&1 ) & )
dm (\d) %%	( ( notify-send -t "%1"000 "%2" "`nice %2 2>&1`" ) & )
## slow:slow (uN|dN|uN dN)
slow u(\d+) d(\d+)	_slow -u %1 -d %2
slow u(\d+)	_slow -u %1
slow d(\d+)	_slow -d %1
slow	@echo usage: slow uN|dN|uN dN
_slow	trickle -s
## nolang:delete LANG and LC_* then run
nolang %	%1	delete $ENV{LANG}; \
                                map { delete $ENV{$_} } \
                                    grep /^LC_/, keys %ENV; \
                                1
## DO:DO [seconds] command args
DO (\d+)	_DO %1
DO	_DO 1
_DO % %%	@while :; do %2; sleep %1; done

# ---- vim: vw/vm/vd/vr/vg

## vw:vim which
vw %%	$EDITOR `which %1`	$ENV{EDITOR}
## vm:vim mru (from viminfo)
vm %%	vv -m %1
## vd:vim file in dir
vd %%	vv %1
## vr:vim file in repo
vr %%	vv -r %1
## vg:vim Grep; vg [iw]* ==> -i/-w
vg i w %%	vg -i -w %1
vg iw %%	vg -i -w %1
vg w i %%	vg -i -w %1
vg wi %%	vg -i -w %1
vg i %%	vg -i %1
vg w %%	vg -w %1
vg %%	$EDITOR -c 'Grep %1'	$ENV{EDITOR}

# ---- text handling: mgrep, InPlace, field, hdt, hd, tc (un/fold)

## mgrep:mgrep word list; grep multiple words, prefix with "-" to exclude.  Last word is colored
mgrep -i	mgrep	$ENV{MG_I}="-i"
mgrep % %%	mgrep %1 | __ mgrep %2
mgrep -%	@grep $MG_I -v %1
mgrep %	@grep $MG_I --color %1

## InPlace:(NO WARNINGS, NO SECOND CHANCES) frompatt topatt filelist...
InPlace -i % %	perl -w -0777 -pi -e "s(%1)(%2)gi"
InPlace % %	perl -w -0777 -pi -e "s(%1)(%2)g"

## field:|field N
field (\d+)	awk '{print $%1}'
## hdt:|hdt
hdt	perl -pe 's/^\d{5,}(\.\d+)?/localtime $&/e'
## hd:|hd; hexdump using od options
hd	od -Ax -tx1z -v

## tc:tc fold|unfold
# I have a lot of files where I use a leading tab as a continuation marker
# (i.e., 'grep' etc should look at those lines as one logical line)
tc fold$	@perl -0777 -pe "s/\n\t/<x0D>/g"
tc unfold$	@perl -pe 's/<x0D>/\n\t/g'

# ---- file handing: ch, lf

## ch:chmod; ch r ==> -R go+rx, w ==> u+w, x ==> +x
ch r	chmod -R go+rX
ch w	chmod u+w
ch x	chmod +x

# lf: <dir> <patt> <count>
## lf:latest files, lf dir? patt? count? (only one or all 3; defaults . . 10)
lf$	lf . . -10
lf (\d+)$	lf . . -%1
lf %$	lf %1 . -10	-d "%1"
lf %$	lf . %1 -10
# canonical form 1
lf % \. -%	ls -Altrc "%1" | tail -%2
# canonical form 2
lf % % -%	ls -Altrc "%1" | grep -i %2 | tail -%3

# ---- git (--, ts/tg, glg, t1/t4)

## --: git checkout - (sweet!)
--	git co -

## ts:tig s (status)
## tg:tig, tg ==> tig, tg b ==> tig --boundary (will cd to repo root dir first)
ts	tg s
tg b	tg --boundary
tg s	tg status
tg	tg CDRR
tg CDRR	cd `git rev-parse --show-toplevel` ; tig

## glg:glg \d* ==> git lg -n(5)
glg$	glg 5
glg (\d+)$	git lg -%1 | less -R -F

## t1
t1 %	TSH_ERREXIT=1 TSH_VERBOSE=1 HARNESS_ACTIVE=1 "%1"
## t4
t4 %	TSH_ERREXIT=1 TSH_VERBOSE=4 HARNESS_ACTIVE=1 "%1"

# ---- system (qf, qd, gu, fssum, flsum)

## qf:rpm -qf (args or STDIN)
qf$	xargs rpm -qf
qf	rpm -qf

## qd:qd rpmname
qd %	less `rpm -qd %1 | grep -v man.man`; man `rpm -qd %1 | grep man.man`

## gu:gaf cycle && gaf pall
gu	gaf cycle && gaf pall

## flsum:|flsum (\d+)?; file list summary, keep upto NUM slashes and summarise
flsum$	flsum 2
flsum %$	perl -pe "s/(([^\/]+\/){%1}).*/\$1/" | sort | uniq -c

## fssum:fssum [dir], print #dirs, #files, size dist
fssum %	fssum	chdir $1
fssum	@du -sm .; \
                echo -e `find . -type d | wc -l `'\tdirectories'; \
                echo -e `find . -type f | wc -l `'\tfiles'; \
                echo '  FILES MB      CUM MB'; \
                find . -type f -print0 | \
                    xargs -0 du -sm | cut -f1 | \
                    sort | uniq -c | sort -k 2nr | \
                perl -lpe '($a,$b)=split;$tot+=$a*$b;$_.="\t$tot"'

# ---- sec (bf, PWGEN, crypdf)

## bf:bf e|d|ea|da
bf ea	bf e -a
bf da	bf d -a
bf e	openssl bf -salt
bf d	openssl bf -d
# TODO: inplace enc/dec

## crypdf:crypdf d|e infile outfile [other flags for enc], (password will be asked on STDIN)
# note: okular as of 2015-06-06 does not read 256 bit encrypted files so no point
crypdf d % %	qpdf --empty --pages %1 --password=`cat` -- %2

crypdf e	crypdf e	chomp($ENV{CP_PW}=<STDIN>); \
                                $ENV{CP_FLAGS}="128 --use-aes=y";\
                                1

crypdf e % % %%$	\
                crypdf e %1 %2	$ENV{CP_FLAGS}.=" %3"; 1

crypdf e % %$	qpdf --empty --pages %1 -- \
                    --encrypt $CP_PW $CP_PW $CP_FLAGS -- \
                    %2

## PWGEN
PWGEN	cat /usr/share/dict/words | \
                    egrep '^.{3,6}$' | \
                    shuf 2>/dev/null | \
                    head -1000 | \
                    egrep '^[a-z]*$' | \
                    column | \
                    head

# ---- misc (dot, mix)

## dot:dot gv-file [png-file] (defaults to ~/junk.png)
dot %$	dot %1 ~/junk.png
dot % %$	/usr/bin/dot -Tpng %1 -o %2; display %2 &
meb	MIX_ENV=prod mix escript.build --force
mt	mix test && git log -1 --format='%h %ai %s' >> .git/test.log

# vim: ts=16:
