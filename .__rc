### other ideas from http://grml.org/zsh/zsh-lovers.html
###
### alias -g CA='|& cat -A'
###     ... similarly for less, egrep, and variants ...
### alias -g NUL="> /dev/null 2>&1"
### alias -g NE="2> /dev/null"
###     ... etc ...
###
### but maybe we'll be happier with prefix form:
###     CA <command>
### or at least
###     NO <command>
###     NE <command>
###     NOE <command>
### other examples
###     TL
###     T20
###     LS

# syntax
# aliasname <TAB> pattern <TAB> replacement
# %% in pattern is (.+); % is (\S+)
# %<digits> in repl is corresponding paren
# rules are matched in sequence

# ---------- ALL ----------
# 'c' field eq 'ALL' means apply this transform to ANY incoming command

# this must come *before* all other transformations, so it is in the shipped
# rc file (the one in the same directory as the binary).

ALL	%% LF	%1 ./LF1
ALL	%% LF(\d)	%1 ./LF%2
ALL	%% (\D\S*)/LF	%1 %2/LF1
ALL	%% %/LF(\d)	%1 %2/`cd %2 ;ls -Atrc|tail -%3|head -1`	print STDERR "+%2/" . `cd %2 ;ls -Atrc|tail -%3|head -1`

ALL	%% Ym-%	%1 `date +%Y-%m-`%2
ALL	%% Ymd-%	%1 `date +%Y-%m-%d-`%2

# ---------- 'dm' (daemonise) ----------
dm	dm %	xdg-open %1 >/dev/null 2>&1	-f "%1" and not -x "%1"
dm	dm (\d) %%	( ( notify-send -t "%1"000 "%2" "`nice %2 2>&1`" ) & )
dm	dm %%	( ( nice %1 >/dev/null 2>&1 ) & )

# ---------- task ----------
tw	tw help$	perl -ne 'next unless /##/; print "\t" unless /^##/; print' ~/.taskrc
tw	tw \.	tw `task _ids | tail -1`
tw	tw (\d+)$	task %1 info
tw	tw %% (\d+)$	task %1 limit:%2
tw	tw ([0-9a-f]{8})$	task `task _uuids | grep %1` info
tw	tw ([0-9a-f]{8}) %%	tw `task _uuids | grep %1` %2
tw	tw %% ::%	task %1 due:%2 wait:%2
tw	tw	task

# this is here as a sample; it won't be any use unless you installed 'ew', but
# you can do this with grep as well if you wish
# ---------- ew ----------
# this one makes it hard to grep for single digits; oh well...
ew	ew ([1-9])	ew -n -%1
ew	ew ([lnv])	ew -%1

# some of these require 'sf' (which is a wrapper over 'find').  As such, they
# won't be generally useful.  Ditto with the vim command 'Grep'.  Overall,
# this is useless for others but shows how canonicalisation happens.
# ---------- vim ----------
# which
vw	vw %%	vim `which %1`
# path
vp	vp % %	sf %1 -f -r %2 -e vim
vp	vp %	sf -f -r %1 -e vim
# file
vf	vf % %	sf %1 -f %2 -e vim
vf	vf %	sf -f %1 -e vim
# line
vl	vl i w %%	vl -i -w %1
vl	vl iw %%	vl -i -w %1
vl	vl w i %%	vl -i -w %1
vl	vl wi %%	vl -i -w %1
vl	vl i %%	vl -i %1
vl	vl w %%	vl -w %1
vl	vl %%	vim -c 'Grep %1'

# ---------- chmod ----------
# most common uses of chmod
ch	ch r	chmod -R go+rX
ch	ch w	chmod u+w
ch	ch x	chmod +x

# ---------- ltrc|ew|tail ----------
# 2 args; note that we don't cater to N > 9 here
lf	lf (\d) %	lf %2 %1
lf	lf % (\d)$	lf %1 . -%2	-d "%1"
lf	lf % (\d)$	lf . %1 -%2
lf	lf % %$	lf %2 %1 -10	not -d "%1"
lf	lf % %$	lf %1 %2 -10
# 1 arg
lf	lf %$	lf %1 . -10	-d "%1"
lf	lf %$	lf . %1 -10
# no args
lf	lf$	lf . . -10
# canonical form 1
lf	lf % \. -%	ls -Altrc "%1" | tail -%2
# canonical form 2
lf	lf % % -%	ls -Altrc "%1" | grep -i %2 | tail -%3

# ---------- tig ----------
ts	ts	tg s
tg	tg b	tg --boundary
tg	tg s	tg status
tg	tg	tg CDRR
tg	tg CDRR	cd `git rev-parse --show-toplevel` ; tig

# many of these are likely to be specific to my environment
# ---------- misc ----------
save	save %%	7z a -tzip -mem=AES256 -r -p /tmp/save.`date -I`.$$ %1 ; rsync -vP /tmp/save.`date -I`.$$ atc:t

# vim: ts=16:
