#!/usr/bin/perl
use strict;
use warnings;
use 5.10.0;
use Data::Dumper;
$Data::Dumper::Indent = 0;

# ----------------------------------------------------------------------

# active aliases -- see http://gitolite.com/active-aliases (or __.mkd in the
# source repo) for documentation

# the idea of applying a series of transformations to a command based on
# matching a list of patterns is not new.  If you don't know where I got it
# from, you're not old enough ;-)

use URI::Escape;

my $script = get_script();
# global; name of script to use if arg-1 is a valid __ script (or a shell
# script, since that may internally have begin/end sections for us).  Also
# shifts ARGV in that case.
say STDERR Dumper [ "script = $script", \@ARGV ] if $ENV{D};

# treat newlines embedded in arguments as argument separators.  This lets you
# operate on "`find ...`" (note the double quotes).
@ARGV = split("\n", join("\n", @ARGV));

# we need the full command as one string, but we take care to escape the
# spaces first, so we can split out arguments properly later
my $fullcmd = join( " ", map { esc($_) } @ARGV );
my $cmd_name = shift || '';

# now we need to get the pattern+replacement list, which is either the shipped
# rc file plus the script given on the command line, or the shipped rc file
# plus all the rc files in the path upto $HOME.  That is, in the latter case:
#       dirname($0)/.__rc   # shipped rc file
#       $PWD/.__rc
#       $PWD/../.__rc       # that is, .__rc in the parent of $PWD
#       ...and so on...     # all the way upto $HOME
# Note: if $PWD is not within $HOME, we behave as if we were in $HOME (i.e.,
# only the shipped rc file and the one in $HOME are used).

# completion help
_commands() if $cmd_name eq '_commands';     # does not return

my @rules = get_rules();

my $cont = '';
for my $r (@rules) {
    my ( $pattern, $repl, $cond ) = @$r;
    say STDERR Dumper [ 'patt/repl/cond', $pattern, $repl, $cond ] if $ENV{D} and $ENV{D} > 1;
    $cond ||= '';    # avoid undef warnings later
    chomp($cond);

    my $f0 = "p=$pattern\nfc=$fullcmd" if $ENV{D};
    # for debug printing only; not needed otherwise

    # replace %% and % in "pattern" string with actual regex sequences
    $pattern =~ s/%%\?/(.+?)/g;
    $pattern =~ s/%%/(.+)/g;
    $pattern =~ s/%/(\\S+)/g;
    $pattern = "^$pattern(?= |\$)";

    # skip if the fullcmd doesn't match the pattern in this line
    next unless $fullcmd =~ qr($pattern);
    say STDERR $f0 if $ENV{D};

    # extract the groups that matched and save them
    my @matches = $fullcmd =~ qr($pattern);
    # add a dummy entry at the start to make the indexes 1-based for
    # convenience in later steps
    unshift @matches, 0;

    # evaluate the extra condition line, if supplied, and skip this line if
    # things didn't work out
    my $rc;
    if ($cond) {
        $cond =~ s/%(\d+)/$matches[$1]/gm;
        $cond = unesc($cond);
        say STDERR "\t?\t$cond" if $ENV{D};
        $rc = eval $cond;
        say STDERR "\t@\t'$@'" if $ENV{D} and not defined($rc);
        say STDERR "\trc\t'$rc'" if $ENV{D} and defined $rc;
        next if not $rc;
    }

    # substitute the cond result (buyer beware!)
    $repl =~ s/%\?/$rc/gm;
    # change the "repl" string using the matched substrings
    $repl =~ s/%(\d+)/$matches[$1]/gm;
    # and if it now contains a backtick, reduce it to the output of the
    # command inside backticks
    if ( $repl =~ /`/ ) {
        say STDERR "`\t$repl" if $ENV{D};
        $repl =~ s/`(.*?)`/_shell($1)/ge;
    }

    # now reduce to the new command
    $fullcmd =~ s($pattern)($repl);
    ($cmd_name) = split ' ', $fullcmd;

    say STDERR "=\t$fullcmd" if $ENV{D};

    last if $fullcmd =~ m(^\@);     # slight optimisation
}

# unescape arguments for execution.  If an argument contains spaces, it is
# quoted so the shell is happy.
$fullcmd = join " ", map { quote_unesc($_) } split / +/, $fullcmd;
$fullcmd = "set -x; $fullcmd" unless $fullcmd =~ s(^\@)();
no warnings;
exec("$fullcmd") or die "__: $cmd_name: command not found\n";

# ----------------------------------------------------------------------

sub _shell {
    my $x = shift;
    $x = `$x`;
    # escape the results of the execution but not across lines
    # XXX WARNING XXX
    # i.e., this behaves like 'map', not 'xargs' (one line is one "item")
    $x = esc($x);
    $x =~ s/\n$//;
    $x =~ s/\n+/ /g;
    return $x;
}

sub esc {
    return uri_escape( +shift, "% " );
    # we don't really want to escape anything except a space but we have
    # to escape the % also, since that is the lead character for the
    # escape sequence
}

sub unesc {
    return uri_unescape( +shift );
}

sub quote_unesc {
    my $in = shift;
    $in = '"' . $in . '"' if $in =~ /%20/;
    return unesc($in);
}

# ----------------------------------------------------------------------

sub get_rc_filenames {
    use Cwd;
    my $bd = $1 if $0 =~ m((.*)/);

    return ("$bd/.__rc") if $script;

    my $home = $ENV{HOME};
    my $cur = getcwd;

    # if we're not starting from a subdir of $home, we pretend we're in $home
    # for the purposes of finding rc files
    $cur = $home if index($cur, $home);

    my @ret = ("$bd/.__rc");    # shipped rc file
    while (1) {
        push @ret, "$cur/.__rc" if -f "$cur/.__rc";
        last if $cur eq $home;
        $cur =~ s(/[^/]+$)();
    }

    if ($ENV{D}) {
        say STDERR Dumper \@ret;
    }

    return @ret;
}

sub _commands {
    my %commands;
    @ARGV = get_rc_filenames();
    while (<>) {
        my $a = $ARGV; $a =~ s(^$ENV{HOME}/)(~/); $a =~ s(/?\.__rc$)();
        next unless s/^## //;
        s/:/:$a:$.\t/;
        print;
    } continue {
        close ARGV if eof;
    }

    exit 0;
}

sub get_rules {
    my @rules;
    @ARGV = get_rc_filenames();

    my $raw = join "", grep { /\S/ } grep { ! /^\s*#/ } <>;
    if ($script) {
        my $s = slurp($script);
        # delete till #!__ marker (if it does not exist, the whole file is ours)
        $s =~ s/.*^#!\S*__\s//ms;
        # delete comments and blank lines, like for $raw above
        $s =~ s(^\s*#.*\n)()gm;
        $s =~ s(^\s*\n)()gm;
        $raw .= $s;
    }
    ## ?? $raw =~ s/^(?=\S)/\n/gm;    # add a blank line

    # backward compat to old syntax (except backslash-line-continuation)
    $raw =~ s/^(\S.*)\t(\S.*)\t(\S.*)/$1\n    $2\n    ?   $3/gm;
    $raw =~ s/^(\S.*)\t(\S.*)/$1\n    $2/gm;

    # this is a pretty rigid structure
    while ($raw =~ m(^(\S.*(\n    .*)*))gm) {
        my $p = $1;
        my ($r, $c);
        $c = $1 if $p =~ s(\n    \?   (.*))()s;
        $r = $1 if $p =~ s(\n    (\S.*))()s;
        die unless $r;  # 'repl' mandatory, 'cond' is not
        # TODO: consider removing the indent from $r and $c, so that multi-line 'echo's work ok
        push @rules, [$p, $r, $c];
    }

    return @rules;
}

# ----------------------------------------------------------------------

sub _open {
    open( my $fh, $_[0], $_[1] ) or die "open $_[1] failed: $!";
    return $fh;
}

sub _print {
    my ( $file, @text ) = @_;
    my $fh = _open( ">", "$file.$$" );
    print $fh @text;
    close($fh) or die "close $file failed: $! at ", (caller)[1], " line ", (caller)[2];
    my $oldmode = ( ( stat $file )[2] );
    rename "$file.$$", $file;
    chmod $oldmode, $file if $oldmode;
}

sub append {
    my ( $file, @text ) = @_;
    _print( $file, slurp($file), @text );
}

sub slurp {
    return unless defined wantarray;
    local $/ = undef unless wantarray;
    my $fh = _open( "<", $_[0] );
    return <$fh>;
}

sub get_script {
    # munges @ARGV
    return '' unless -f $ARGV[0];
    my $fh = _open( "<", $ARGV[0]) ;
    return '' unless <$fh> =~ m(^#!.*(__|sh));
    my $f = shift @ARGV;
    $ENV{__SCRIPT} = $f;
    return $f;
}
