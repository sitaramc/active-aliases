#!/usr/bin/perl
use strict;
use warnings;
use 5.10.0;

# active aliases -- see http://gitolite.com/active-aliases (or __.mkd in the
# source repo) for documentation

# NOTE: at present the "config" for this is right here in this file.  If
# anyone other than me actually starts using it, it may be worth moving into a
# separate file so the code can be updated cleanly.

use URI::Escape;

# we need the full command as one string, but we take care to escape the
# spaces first, so we can split out arguments properly later
my $fullcmd = join( " ", map { esc($_) } @ARGV );
my $cmd_name = shift;

# TODO: this needs to go into its own config file eventually
while (<DATA>) {
    chomp; next unless /\S/; next if /^\s*#/;

    my ( $cmd, $pattern, $repl, $cond ) = split /\t/;
    next unless $cmd eq $cmd_name or $cmd eq 'ALL';
    # 'cmd' field eq 'ALL' means apply this transform to ANY incoming command
    $cond ||= '';    # avoid undef warnings later

    my $f0 = "$.\t$pattern" if $ENV{D};
    # for debug printing only; not needed otherwise

    # replace %% and % in "pattern" string with actual regex sequences
    $pattern =~ s/%%/(.+)/g;
    $pattern =~ s/%/(\\S+)/g;
    $pattern = "^$pattern(?= |\$)";

    # skip if the fullcmd doesn't match the pattern in this line
    next unless $fullcmd =~ qr($pattern);
    say STDERR $f0 if $ENV{D};

    # extract the groups that matched and save them
    my @matches = $fullcmd =~ qr($pattern);
    # add a dummy entry at the start to make the indexes 1-based for
    # convenience in later steps
    unshift @matches, 0;

    # evaluate the extra condition line, if supplied, and skip this line if
    # things didn't work out
    if ($cond) {
        $cond =~ s/%(\d+)/$matches[$1]/gm;
        $cond = unesc($cond);
        say STDERR "?\t$cond" if $ENV{D};
        next if not eval $cond;
    }

    # change the "repl" string using the matched substrings
    $repl =~ s/%(\d+)/$matches[$1]/gm;
    # and if it now contains a backtick, reduce it to the output of the
    # command inside backticks
    if ( $repl =~ /`/ ) {
        say STDERR "`\t$repl" if $ENV{D};
        $repl =~ s/`(.*?)`/_shell($1)/ge;
    }

    # now reduce to the new command
    $fullcmd =~ s($pattern)($repl);
    ($cmd_name) = split ' ', $fullcmd;

    say STDERR "=\t$fullcmd" if $ENV{D};
}

# unescape arguments for execution.  If an argument contains spaces, it is
# quoted so the shell is happy.
$fullcmd = join " ", map { quote_unesc($_) } split ' ', $fullcmd;
say STDERR "+$fullcmd";
exec("$fullcmd") or die "exec '$fullcmd' failed: $!";

# ----------------------------------------------------------------------

sub _shell {
    my $x = shift;
    $x = `$x`;
    chomp $x;
    $x =~ s/\n+/ /g;
    # escape the results of the execution
    # XXX WARNING XXX
    # this means we assume each execution can at most create one "word"
    return esc($x);
}

sub esc {
    return uri_escape( +shift, "%\\s" );
    # we don't really want to escape anything except a space but we have
    # to escape the % also, since that is the lead character for the
    # escape sequence
}

sub unesc {
    return uri_unescape( +shift );
}

sub quote_unesc {
    my $in = shift;
    $in = '"' . $in . '"' if $in =~ /%20/;
    return unesc($in);
}

# ----------------------------------------------------------------------

### other ideas from http://grml.org/zsh/zsh-lovers.html
###
### alias -g CA='|& cat -A'
###     ... similarly for less, egrep, and variants ...
### alias -g NUL="> /dev/null 2>&1"
### alias -g NE="2> /dev/null"
###     ... etc ...
###
### but maybe we'll be happier with prefix form:
###     CA <command>
### or at least
###     NO <command>
###     NE <command>
###     NOE <command>
### other examples
###     TL
###     T20
###     LS

# syntax
# aliasname <TAB> pattern <TAB> replacement
# %% in pattern is (.+); % is (\S+)
# %<digits> in repl is corresponding paren
# rules are matched in sequence

__DATA__
# ---------- ALL ----------
# 'c' field eq 'ALL' means apply this transform to ANY incoming command

ALL	%% LF	%1 ./LF1
ALL	%% LF(\d)	%1 ./LF%2
ALL	%% (\D\S*)/LF	%1 %2/LF1
ALL	%% %/LF(\d)	%1 %2/`cd %2 ;ls -Atrc|tail -%3|head -1`	print STDERR "+%2/" . `cd %2 ;ls -Atrc|tail -%3|head -1`

ALL	%% Ym-%	%1 `date +%Y-%m-`%2
ALL	%% Ymd-%	%1 `date +%Y-%m-%d-`%2

ALL	%% %/BN	%1 %2/`basename $PWD`

# ---------- 'dm' (daemonise) ----------
dm	dm %	xdg-open %1 >/dev/null 2>&1	-f "%1" and not -x "%1"
dm	dm (\d) %%	( ( notify-send -t "%1"000 "%2" "`nice %2 2>&1`" ) & )
dm	dm %%	( ( nice %1 >/dev/null 2>&1 ) & )

# ---------- task ----------
tw	tw help$	perl -ne 'next unless /##/; print "\t" unless /^##/; print' ~/.taskrc
tw	tw \.	tw `task _ids | tail -1`
tw	tw (\d+)$	task %1 info
tw	tw %% (\d+)$	task %1 limit:%2
tw	tw ([0-9a-f]{8})$	task `task _uuids | grep %1` info
tw	tw ([0-9a-f]{8}) %%	tw `task _uuids | grep %1` %2
tw	tw %% ::%	task %1 due:%2 wait:%2
tw	tw	task

# ---------- ew ----------
# this one makes it hard to grep for single digits; oh well...
ew	ew ([1-9])	ew -n -%1
ew	ew ([lnv])	ew -%1

# ---------- vim ----------
# which
vw	vw %%	vim `which %1`
# path
vp	vp % %	sf %1 -f -r %2 -e vim
vp	vp %	sf -f -r %1 -e vim
# file
vf	vf % %	sf %1 -f %2 -e vim
vf	vf %	sf -f %1 -e vim
# line
vl	vl i w %%	vl -i -w %1
vl	vl iw %%	vl -i -w %1
vl	vl w i %%	vl -i -w %1
vl	vl wi %%	vl -i -w %1
vl	vl i %%	vl -i %1
vl	vl w %%	vl -w %1
vl	vl %%	vim -c 'Grep %1'

# ---------- chmod ----------
ch	ch r	chmod -R go+rX
ch	ch w	chmod u+w
ch	ch x	chmod +x

# ---------- ltrc|ew|tail ----------
# 2 args; note that we don't cater to N > 9 here
lf	lf (\d) %	lf %2 %1
lf	lf % (\d)$	lf %1 . -%2	-d "%1"
lf	lf % (\d)$	lf . %1 -%2
lf	lf % %$	lf %2 %1 -10	not -d "%1"
lf	lf % %$	lf %1 %2 -10
# 1 arg
lf	lf %$	lf %1 . -10	-d "%1"
lf	lf %$	lf . %1 -10
# no args
lf	lf$	lf . . -10
# canonical form 1
lf	lf % \. -%	ls -Altrc "%1" | tail -%2
# canonical form 2
lf	lf % % -%	ls -Altrc "%1" | grep -i %2 | tail -%3

# ---------- tig ----------
ts	ts	tg s
tg	tg b	tg --boundary
tg	tg s	tg status
tg	tg	tg CDRR
tg	tg CDRR	cd `git rev-parse --show-toplevel` ; tig

save	save %%	7z a -tzip -mem=AES256 -r -p /tmp/save.`date -I`.$$ %1 ; rsync -vP /tmp/save.`date -I`.$$ atc:t

# vim: ts=16:
