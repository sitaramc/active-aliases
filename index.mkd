<!-- options: toc to=html-N -->

% active aliases

"Active aliases" is a somewhat pretentious name I cooked up for a very simple
way to write complex commands, especially in terms of argument handling.

General info, examples, and "Getting started" instructions are in the
[README][].  This document is more of a reference.

[README]: https://github.com/sitaramc/active-aliases/blob/master/README.markdown

# syntax and semantics

## rule syntax and how it all works {#syn}

@@box-r(Note: the idea of applying a series of transformations to something,
based on matching a list of patterns is not new.  If you don't know where I
got it from, you're not old enough ;-))@@

I assume you've looked at the first few examples in the [README][] to get some
familiarity with this syntax.

Each rule has 3 parts: a pattern, a replacement, and an optional "condition".

The syntax for each rule is:

    pattern
        replacement command (shell)
        (optional: more lines of replacement command)
        ?   condition code (perl)
            (optional: more lines of condition code)

I realise this is hypocritical for a guy who doesn't like
whitespace-as-syntax, but:

-   the pattern is flush left (starts at column 1)

-   the replacement starts exactly 4 spaces later.  Subsequent lines, if any,
    are indented at least 4 spaces.

-   the condition starts with a `?` in column 5, and the actual code for the
    condition in column 9.  Subsequent lines, if any, are indented at least 8
    spaces.

At the beginning, the program has a notion of the **current command** being
processed.  As each rc rule is read, this current command may be replaced by
("morph into") something else.  When *all* the rules have been read and
processed, whatever remains is executed as a shell command.

Here's some more detail about the 3 fields:

1.  The **pattern** is what the current command is matched against.  If it
    doesn't match, the rule is skipped.  The field is a perl regex, and may
    contain parenthesised sub-expressions.  @@gray((Any regular expression
    tutorial will help you with that if needed))@@.

    It usually contains one or more `%` and/or `%%` signs.  A `%` matches a
    series of non-space characters, while `%%` a series of any characters.
    They are both considered parenthesised sub-expressions; you don't have to
    put them in parentheses.

    (For regex-aware people, there's also `%%?`, which is a non-greedy version
    of `%%`.  Discussion of greediness in a regex quantifier is out of scope
    of this documentation, but can be obtained from pretty much any decent
    regex tutorial or help page).

    The pattern need not match the entire current command unless it ends with
    a `$`.  Only the part of the "current command" that matches this pattern
    will be morphed.  The rest will stay as-is.

2.  The **replacement** field is the new (morphed) command.

    This only happens if there is either no "condition" field (see next
    section), or there is one and it evaluates to true.  If a "cond" field
    exists and evaluates to false, the morphing is skipped and the next rule
    is checked.

    When morphing happens, variables like %1 and %2 etc.  are replaced by the
    corresponding matched subgroups in the regex match in the previous step.
    Each `%` and `%%` is a sub-group.  You may also insert your own subgroups
    (like the `(\d+)` in some of the examples in the [README][]).  (Perl
    gurus: sorry we don't support named captures, and probably never will;
    they would complicate the syntax too much!)

    As you can see, this means a command may potentially be changed multiple
    times before reaching the end of all the rc lines and being executed.

3.  The **condition** field is *optional* code that is evaluated as a **perl
    expression**.  The next section explains its use with examples.

    The condition may also contain variables like %1 and %2, which are
    replaced by corresponding matched subgroups, before the expression is
    evaluated.

    The expression is evaluated in the context of the main `__` program, and
    it can use environment variables to save data and reuse it in later steps.
    It can also perform persistent actions like changing the current
    directory, etc.

### quiet mode

Normally, **aa** helpfully prints (to STDERR) the final command it is going to
execute.  However, if the replacement starts with an `@` sign, then this is
suppressed.

Secondly, it is assumed that this replacement can no longer match any pattern
yet to be seen, so the rest of the patterns are skipped.

## using conditions

Here's a bit of a tough one:

    # set screen brightness: default 5, min 3 max 99.
    dim$
        dim 5
    dim [0-2]$
        @echo need number [3-99]
    dim [1-9][0-9][0-9]+$
        @echo need number [3-99]
    dim (\d+)$
        @xbacklight -set %1
    dim %%
        @echo need number [3-99]

This is better than writing it in shell, but not *much* better; some of the
rough edges are showing up.

To help with that, we define a third field, which is a **condition** to be
met.  If it fails, the command is *not* morphed according to this line, and
the next line is attempted.

Here's the previous example again, with a conditional this time.  The maximum
brightness is now 59, which would have been even more cumbersome in the
previous example (a max of 99 allowed us to cheat by testing number of digits
instead of the actual value!).  (We added line numbers for discussion).

    1       dim$
    2           dim 5
    3       dim (\d+)$
    4           xbacklight -set %1
    5           ?   %1 >= 3 and %1 <= 59
    6       dim %%
    7           @echo need number [3-59]

When line 3 matches the command, the condition is evaluated, with `%1` being
the matched text in the first matched subgroup (in this case, `\d+`).  The
condition on line 5 is evaluated, and if it is true, the replacement comes
from line 4.  This matches no further patterns so it eventually executes.

If the condition fails, the replacement on line 4 is skipped, and we try to
match line 6.  The `%%` will match pretty much anything, but we ignore it in
the replacement command, which is merely an echo statement.

## rc files {#rcfiles}

The [README][] only mentioned `~/.__rc`.  But actually, for command line
tasks, the program picks up rc files in the following order.  The combined
content of all of them is what is used:

1.  `.__rc` from the same directory (typically something in the PATH) where
    `__` itself is installed.
2.  `.__rc` in the current directory, if it exists.
3.  `.__rc` in its parent directory, if it exists, and so on for each
    successive parent directory, all the way upto \$HOME.

Note that this allows directory-specific aliases -- aliases that would only
apply in a specific directory (or underneath it).  For example, I have several
aliases that are really only applicable to my gitolite development and testing
tasks, so they live in a `.__rc` file in the gitolite source directory.

**SECURITY NOTE**: If your current directory is not \$HOME (say your PWD is
/tmp or something), then this will behave as if you were in \$HOME (i.e., it
will *never* look for rc files outside your home directory tree).

## invocation {#inv}

You can invoke `__` in the following ways:

1.  Without "unknown command helper":

    -   for commands that you use frequently, setup aliases like this:

            alias foo='__ foo'

        Don't worry; this won't recurse forever, assuming foo is originally an
        executable program of some kind (i.e., not a shell builtin, shell
        function, or alias)

    -   for commands that you use rarely, run it explicitly if you want
        "active alias" support

            __ cpu cool

3.  With "unknown command helper" feature of bash or zsh.

    See appendix 1 for the code for this function.  Once you put it in your
    `~/.zshrc` or `~/.bashrc`, you can just say

            cpu cool

    and if there isn't another command, function, or alias called `cpu`, you
    will get `__ cpu cool`.

    It's worth repeating that this makes it possible to use pretty much
    **anything** as an implicit alias simply by putting it in an `.__rc` file.
    However, should a real command of that name ever get installed by some
    means, things may get confusing!

# appendix 1 -- unknown command helper code

Here's the code for zsh.  Note that on bash the function should be called
`command_not_found_handle` (yes -- one letter at the end dropped!)

    command_not_found_handler() {
        __ "$@"
        exit $? 2>/dev/null
    }

