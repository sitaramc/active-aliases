<!--
    options: toc
    to: html-N
-->

% active aliases

"Active aliases" is a somewhat pretentious name I cooked up for a very simple
way to write complex commands, especially in terms of argument handling.
Clone the [repo](https://github.com/sitaramc/active-aliases) or grab the
[script](https://github.com/sitaramc/active-aliases/blob/master/__) and the
[sample rc
file](https://github.com/sitaramc/active-aliases/blob/master/.__rc).

# basics and some quick examples

@@box-r(The program itself is called `__` (yes, that's two underscores), but
as you will see in the [invocation][inv] section, I rarely even type that.)@@

Zsh has something called "global aliases", which are aliases that expand
anywhere on the command line, not just in the command name.  I wanted
something like that, but (a) I don't have zsh everywhere I need to work, (b) I
want them to expand differently for different commands.

For example, I want `ch r ...` to expand to `chmod -R go+rX ...`, but `gpg r
...` to expand to `gpg -r sitaramc@gmail.com ...`, even though in both cases
the word being expanded is the same (the letter 'r').

@@box-r(Although you can't see it here, the rc file is TAB delimited; so just
pretend you can see the hard tabs where there are several space characters!)@@

What I came up with is a way to take a command, and keep morphing it into
something else, possibly in multiple steps, and execute whatever comes out at
the end.  At each step, the replacement becomes the new command, which may be
quite different from the old one.  (Note: until you read the [syntax][syn]
section, just ignore the first column!)

Here's a *very small* example.  Notice how, if you give it just 'glg', it
pretends you gave it 'glg 5' and proceeds from there:

    # show last N (default 5) git commit subject lines
    glg         glg$            glg 5
    glg         glg (\d+)$      git log --oneline -%1 | less -R -F

Here is one more really simple one, where you can guess not only what `ch r
/tmp/foo` should do, but also that a more elegant way to do this simply cannot
exist :-)

    ch          ch r            chmod -R go+rX
    ch          ch w            chmod u+w
    ch          ch x            chmod +x

# features/concepts

## morphing the command in steps

@@box-r(Note: the idea of applying a series of transformations to something,
based on matching a list of patterns is not new.  If you don't know where I
got it from, you're not old enough ;-))@@

Here's an example of an alias that allows me to say 'cg cool', or 'cg fast',
to set predefined CPU frequency governors, or for example, 'cg powersave'
etc., for other governors without their own shortcut word.  In addition, if I
type just 'cg', I get 'cg cool'.

    cg          cg$             cg cool
    cg          cg cool$        cg ondemand
    cg          cg fast$        cg performance
    cg          cg              cpupower -c all frequency-set -g

Actually, 'cg' morphs to 'cg cool', then 'cg cool' morphs to 'cg ondemand',
and *that* finally morphs to 'cpupower -c all frequency-set -g ondemand'.

Here's a slightly longer, but still very simple, example.  I often encrypt
files, either with my gpg key, or with an ad hoc (manually typed) symmetric
key.  Also, sometimes I want the files ASCII-armored, and sometimes not.  I
want to type the minimum number of characters needed, but I can never remember
if it should be "ac" or "ca", so I want to allow both.  This gives me six
possible arguments to my new "enc" command:

    enc         enc ca          enc c -a
    enc         enc ac          enc c -a
    enc         enc ra          enc r -a
    enc         enc ar          enc r -a
    enc         enc c           gpg -c --cipher-algo AES256
    enc         enc r           gpg -e -r sitaramc@gmail.com

When you type in "enc ca file", the first line converts it to "enc c -a file".
Then the next 3 lines don't match, and the 5th line converts it to "gpg -c
--cipher-algo AES256 -a file".  You can work out the other flows in a similar
fashion.

If you were to do this in a shell function, you'd need several 'if'
statements, and it would look quite ugly.  The simple flow above is much more
readable.

## using conditions

Here's a bit of a tough one:

    # set screen brightness: default 5, min 3 max 99.
    dim     dim$                    dim 5
    dim     dim [0-2]$              @echo need number [3-99]
    dim     dim [1-9][0-9][0-9]+$   @echo need number [3-99]
    dim     dim (\d+)$              @xbacklight -set %1
    dim     dim %%                  @echo need number [3-99]

@@box-r(NOTE: a bit of regex knowledge assumed here, like capture groups.
Also, see the [rc line syntax][syn] section later for what %% means.)@@

This is better than writing it in shell, but not *much* better; some of the
rough edges are showing up.

To help with that, we define a fourth field, which is a **condition** to be
met.  If it fails, the command is *not* morphed according to this line, and
the next line is attempted.

Here's the previous example again, with a conditional this time.  The maximum
brightness is now 59, which would have been even more cumbersome in the
previous example (a max of 99 allowed us to cheat by testing number of digits
instead of the actual value!).

    dim     dim$        dim 5
    dim     dim (\d+)$  xbacklight -set %1         %1 >= 3 and %1 <= 59
    dim     dim %%      @echo need number [3-59]

What's happening here is, when line 2 is encountered, the pattern is matched,
then the condition, since it exists, is evaluated before allowing the command
to be morphed into `xbacklight ...`.  If the condition evaluates to false, the
command is NOT morphed; it remains "dim (something)" instead of becoming
"xbacklight -set (something)", and thus matches the next line's pattern.

# more examples

## shallow recursion -- multi grep {#mgrep}

I often have to do something like this:

    ... | grep foo | grep -v bar | grep baz

The following rc lines allow me to just say `... | mgrep foo -bar baz`:

    mgrep          mgrep % %%         mgrep %1 | __ mgrep %2
    mgrep          mgrep -%           @grep -v %1
    mgrep          mgrep %            @grep    %1

With a little extra, you can also allow "-i" (ignore case option):

    mgrep          mgrep -i           mgrep                     $ENV{MG_I)="-i"
    mgrep          mgrep % %%         mgrep %1 | __ mgrep %2
    mgrep          mgrep -%           @grep $MG_I -v %1
    mgrep          mgrep %            @grep $MG_I %1

Note the first line specifies a "morph" that removes the "-i", and the
"condition" has a side-effect of setting the environment variable, which is
used later in the grep command invocations.

(I wouldn't go too deep with this; each word adds one process to the pipe, but
for most human needs, it should do fine!)

## the unmatched part of the command line

Here's one that lets me edit a base set of files (i.e., those in
`~/.gitolite/conf`) if I run just the command, but if I add "-a" it lets me
edit the base set *and* some other files (i.e., gl-conf files in first level
repositories):

    vconf       vconf -a$       vconf $HOME/repositories/*.git/gl-conf
    vconf       vconf           vconf $HOME/.gitolite/conf/*
    vconf       vconf           ${EDITOR:-vim}

How does this work?  At each stage, only the part of the current command that
matches the pattern is morphed.  Anything left over (unmatched) from the old
command remains, unchanged, after the morphed part.  Here's what the command
looks like after each line, starting from 'vconf -a'.

    1:  vconf $HOME/repositories/*.git/gl-conf
    2:  vconf $HOME/.gitolite/conf/* $HOME/repositories/*.git/gl-conf
        ^--- matched/morphed ------^ ^-- unmatched (carried over) --^
    3:    vim $HOME/.gitolite/conf/* $HOME/repositories/*.git/gl-conf

## argument parsing the easy way

Here's our final example, showing several tricks.

What it does is allow me to start youtube downloads using either the URL
itself, or the name of a file that was (maybe partially) downloaded, since the
file name contains the youtube "id" (that random 10-digit string you see in
youtube URLs).

    yd      yd                      yd                      chdir "$ENV{HOME}/yt"
    yd      yd http%                _yd http%1
    yd      yd %.part               yd %1
    yd      yd .*-(\S{10,})\.\w+$   _yd https://www.youtube.com/watch?v=%1
    _yd     _yd                     youtube-dl

Points to note:

*   the first line has the 2nd field equal to the 3rd field, so it doesn't
    matter if the command morphs in this line or not.  Therefore, the value of
    the conditional expression is irrelevant; we're only using it for its
    side-effect: in this case, the 'chdir'.

*   if an argument starting with http is seen, the second line *changes the
    command name* from `yd` to `_yd`.  This is a clever way to *bypass* all
    other lines matching the 'yd' command.

*   a trailing ".part" is removed from the argument in the 3rd line.  This is
    the kind of thing where the idea of step-by-step morphing a command line
    becomes really intuitive.

*   and finally, the 4th line gets the juicy bit (the 10-character youtube
    "id") from the file name, constructs a URL from it, and (like line 2)
    changes the command name to `_yd`.  In spirit, this isn't much different
    from line 3, just that the expression is a bit more complex.

Why couldn't we remove line 5 and simply use 'youtube-dl' in lines 2 and 4?
We could, but if we want to add any default arguments etc., later, we'd need
to add them in two places.

Try that in any shell :)

# details

## rc files {#rcfiles}

The program picks up rc files in the following order.  The combined content of
all of them is what is used:

1.  `.__rc` from the same directory (typically something in the PATH) where
    `__` itself is installed.
2.  `.__rc` in the current directory, if it exists.
3.  `.__rc` in its parent directory, if it exists, and so on for each
    successive parent directory, all the way upto \$HOME.

Note that this allows directory-specific aliases -- aliases that would only
apply in a specific directory (or underneath it).  For example, I have several
aliases that are really only applicable to my gitolite development and testing
tasks, so they live in a `.__rc` file in the gitolite source directory.

SECURITY NOTE: If your current directory is not \$HOME (say your PWD is /tmp
or something), then this will behave as if you were in \$HOME (i.e., it will
*never* look for rc files outside your home directory tree).

## rc line syntax and how it all works {#syn}

Each line in the rc file(s) has at least three fields, with an optional fourth
field, as described below.  Fields are separated by HARD TABs.  @@gray(PLEASE
NOTE that you should avoid comments on the same line; put comments on their
own lines please!)@@

At the beginning, the program has a notion of the **current command** being
processed.  As each rc line is read, this current command may change ("morph")
into something else.  When *all* the lines have been read and processed,
whatever remains is executed as a shell command.

Each rc line has 4 fields.

1.  The first field is used to match the first word of the current command.
    If it doesn't match, that rc line is skipped.  This is an optimisation to
    speed up things a bit, since you have all sorts of unrelated aliases in
    the same file.

    Also, if this field contains the special word "ALL", then any command
    matches.

2.  The "from" field is a pattern that the current command is matched against.
    If it doesn't match, the rc line is skipped.  The field is a perl regex,
    and may contain parenthesised sub-expressions.  @@gray((Any regular
    expression tutorial will help you with that if needed))@@.

    It usually contains one or more `%` and/or `%%` signs.  A `%` matches the
    "rest of the word", while `%%` is "rest of the line".  They are both
    considered parenthesised sub-expressions; you don't have to put them in
    parentheses.

    The pattern need not match the entire current command unless it ends with
    a `$`.  Only the part of the "current command" that matches this pattern
    will be morphed.  The rest will stay as-is.  (There's an example of this
    in the "showpiece examples" section above.)

3.  The "to" field is the new (morphed) command.  Variables like %1 and %2
    etc.  are replaced by the corresponding matched subgroups in the regex
    match in the previous step.

    This only happens if there is either no "cond" field (see next bullet), or
    there is one and it evaluates to true.  If a "cond" field exists and
    evaluates to false, the morphing is skipped and the next rc line is read.

    As you can see, this means a command may potentially be changed multiple
    times before reaching the end of all the rc lines and being executed.

4.  The "cond" field is *optional* code that is evaluated as a perl
    expression.  It may also contain variables like %1 and %2, which are
    replaced by corresponding matched subgroups, before the expression is
    evaluated.

    The expression is evaluated in the context of the main `__` program, and
    it can use global and environment variables to save data and reuse it in
    later steps.  It can also do persistent actions like changing the current
    directory, etc.

## invocation {#inv}

You can invoke `__` in the following ways:

1.  for commands that you use frequently, setup aliases like this:

        alias foo='__ foo'

    Don't worry; this won't recurse forever, assuming foo is originally an
    executable program of some kind (i.e., not a shell builtin, shell
    function, or alias)

2.  for commands that you use rarely, run it explicitly if you want "active
    alias" support.  For example, this will run vlc on the last updated file
    in the current directory.  (See example 4 below for details).

        __ vlc LF

3.  use the "unknown command helper" feature of bash or zsh.  This helps you
    create new aliases by adding them directly into the rc lines for the
    `__` program.

    When you run the command, the shell runs the "unknown command helper"
    (since it can't find such a command, alias, or function), which then runs
    `__` appripriately.  See appendix 1 for the code for this function.

    It's worth repeating that this makes it possible to use pretty much
    **anything** as an implicit alias simply by putting it in this file.
    However, should a real command of that name ever get installed by some
    means, you may have a bit of a confusing time until you realise what
    happened.  At that point, the best thing is to go to method 1 or 2,
    depending on how frequent your use of it is.

## installation

Just put it in your path somewhere.

# appendix 1 -- unknown command helper code

Here's the code.  Note that on bash the function should be called
`command_not_found_handle` (yes -- one letter at the end dropped!)

    command_not_found_handler() {
        if grep >/dev/null "^$1	" `which __`
        then
            __ "$@"
            exit $?
        fi
        unset -f command_not_found_handler      # XXX do we need this?
        exec $SHELL -c "$@"
            # punt to shell.  Note that this is one SHLVL down in zsh
    }
