<!-- options: toc to=html-N -->

% active aliases

"Active aliases" is a somewhat pretentious name I cooked up for a very simple
way to write complex commands, especially in terms of argument handling.
Clone the [repo](https://github.com/sitaramc/active-aliases) or grab the
[script](https://github.com/sitaramc/active-aliases/blob/master/__) and the
[sample rc
file](https://github.com/sitaramc/active-aliases/blob/master/.__rc).

# basics and some quick examples

@@box-r(The program itself is called `__` (yes, that's two underscores), but
as you will see in the [invocation][inv] section, I rarely even type that.)@@

Zsh has something called "global aliases", which are aliases that expand
anywhere on the command line, not just in the command name.  I wanted
something like that, but (a) I don't have zsh everywhere I need to work, (b) I
want them to expand differently for different commands.

For example, I want `ch r ...` to expand to `chmod -R go+rX ...`, but `gpg r
...` to expand to `gpg -r sitaramc@gmail.com ...`, even though in both cases
the word being expanded is the same (the letter 'r').

What I came up with is a way to take a command, and keep morphing it into
something else, possibly in multiple steps, and execute whatever comes out at
the end.  At each step, the replacement becomes the new command, which may be
quite different from the old one.

Here's a *very small* example.  Notice how, if you give it just 'glg', it
pretends you gave it 'glg 5' and proceeds from there:

    # show last N (default 5) git commit subject lines
    glg$
        glg 5
    glg (\d+)$
        git log --oneline -%1 | less -R -F

Here is one more really simple one, where you can guess not only what `ch r
/tmp/foo` should do, but also that a more elegant way to do this simply cannot
exist :-)

    ch r
        chmod -R go+rX
    ch w
        chmod u+w
    ch x
        chmod +x

## an important note about the syntax

As of 2017-01-26, the syntax has been changed somewhat.  There's a whole
section devoted to syntax later, but note that the above can also, for
convenience, be written as:

    ch r    chmod -R go+rX
    ch w    chmod u+w
    ch x    chmod +x

Except it needs a **hard tab** just between the comand and the replacement.
We will use this syntax where convenient, please assume the hard tabs are
there!

# features/concepts

## morphing the command in steps

@@box-r(Note: the idea of applying a series of transformations to something,
based on matching a list of patterns is not new.  If you don't know where I
got it from, you're not old enough ;-))@@

Here's an example of an alias that allows me to say 'cg cool', or 'cg fast',
to set predefined CPU frequency governors, or for example, 'cg powersave'
etc., for other governors without their own shortcut word.  In addition, if I
type just 'cg', I get 'cg cool'.

    cg$             cg cool
    cg cool$        cg ondemand
    cg fast$        cg performance
    cg              cpupower -c all frequency-set -g

Actually, 'cg' morphs to 'cg cool', then 'cg cool' morphs to 'cg ondemand',
and *that* finally morphs to 'cpupower -c all frequency-set -g ondemand'.

Here's a slightly longer, but still very simple, example.  I often encrypt
files, either with my gpg key, or with an ad hoc (manually typed) symmetric
key.  Also, sometimes I want the files ASCII-armored, and sometimes not.  I
want to type the minimum number of characters needed, but I can never remember
if it should be "ac" or "ca", so I want to allow both.  This gives me six
possible arguments to my new "enc" command:

    enc ca          enc c -a
    enc ac          enc c -a
    enc ra          enc r -a
    enc ar          enc r -a
    enc c           gpg -c --cipher-algo AES256
    enc r           gpg -e -r sitaramc@gmail.com

When you type in "enc ca file", the first line converts it to "enc c -a file".
Then the next 3 lines don't match, and the 5th line converts it to "gpg -c
--cipher-algo AES256 -a file".  You can work out the other flows in a similar
fashion.

If you were to do this in a shell function, you'd need several 'if'
statements, and it would look quite ugly.  The simple flow above is much more
readable.

## using conditions

Here's a bit of a tough one:

    # set screen brightness: default 5, min 3 max 99.
    dim$                    dim 5
    dim [0-2]$              @echo need number [3-99]
    dim [1-9][0-9][0-9]+$   @echo need number [3-99]
    dim (\d+)$              @xbacklight -set %1
    dim %%                  @echo need number [3-99]

@@box-r(NOTE: a bit of regex knowledge assumed here, like capture groups.
Also, see the [rc line syntax][syn] section later for what %% means.)@@

This is better than writing it in shell, but not *much* better; some of the
rough edges are showing up.

To help with that, we define a third field, which is a **condition** to be
met.  If it fails, the command is *not* morphed according to this line, and
the next line is attempted.

Here's the previous example again, with a conditional this time.  The maximum
brightness is now 59, which would have been even more cumbersome in the
previous example (a max of 99 allowed us to cheat by testing number of digits
instead of the actual value!).

    dim$        dim 5
    dim (\d+)$  xbacklight -set %1
        ?   %1 >= 3 and %1 <= 59
    dim %%      @echo need number [3-59]

What's happening here is, when line 2 is encountered, the pattern is matched,
then the condition given on the next line is evaluated before allowing the
command to be morphed into `xbacklight ...`.  If the condition evaluates to
false, the command is NOT morphed; it remains "dim (something)" instead of
becoming "xbacklight -set (something)", and thus matches the next line's
pattern.

# more examples

## shallow recursion -- multi grep {#mgrep}

I often have to do something like this:

    ... | grep foo | grep -v bar | grep baz

The following rc lines allow me to just say `... | mgrep foo -bar baz`:

    mgrep % %%         mgrep %1 | __ mgrep %2
    mgrep -%           @grep -v %1
    mgrep %            @grep    %1

With a little extra, you can also allow an explicit "-i" (ignore case option):

    mgrep -i           mgrep                     $ENV{MG_I}="-i"
    mgrep % %%         mgrep %1 | __ mgrep %2
    mgrep -%           @grep $MG_I -v %1
    mgrep %            @grep $MG_I %1

Note the first line specifies a "morph" that removes the "-i", and the
"condition" has a side-effect of setting the environment variable, which is
used later in the grep command invocations.

You can also get "smartcase" (a nice feature where, if the pattern has any
uppercase letters, it is considered case-sensitive, but if it is all
lowercase, then a "-i" is implied):

    mgrep % %%         mgrep %1 | __ mgrep %2
    mgrep              mgrep
        ?   "%1" !~ /[A-Z]/ and  $ENV{MG_I}="-i"
    mgrep -%           @grep $MG_I -v %1
    mgrep %            @grep $MG_I %1

Here, we're using the "condition" field in the second rule to set an
environment variable as a side effect, and using that later.  The actual
command does not change at all, since the replacement is the same as the
pattern.

(I wouldn't go too deep; each word adds one process to the pipe, but for most
human needs, it should do fine!)

## the unmatched part of the command line

Here's one that lets me edit a base set of files (i.e., those in
`~/.gitolite/conf`) if I run just the command, but if I add "-a" it lets me
edit the base set *and* some other files (i.e., gl-conf files in first level
repositories):

    vconf -a$       vconf $HOME/repositories/*.git/gl-conf
    vconf           vconf $HOME/.gitolite/conf/*
    vconf           ${EDITOR:-vim}

How does this work?  At each stage, only the part of the current command that
matches the pattern is morphed.  Anything left over (unmatched) from the old
command remains, unchanged, after the morphed part.  Here's what the command
looks like after each line, starting from 'vconf -a'.

    1:  vconf $HOME/repositories/*.git/gl-conf
    2:  vconf $HOME/.gitolite/conf/* $HOME/repositories/*.git/gl-conf
        ^--- matched/morphed ------^ ^-- unmatched (carried over) --^
    3:    vim $HOME/.gitolite/conf/* $HOME/repositories/*.git/gl-conf

## argument parsing the easy way

Here's our final example, showing several tricks.

What it does is allow me to start youtube downloads using either the URL
itself, or the name of a file that was (maybe partially) downloaded, since the
file name contains the youtube "id" (that random 10-digit string you see in
youtube URLs).

    yd                      yd
        ?   chdir "$ENV{HOME}/yt"
    yd http%                _yd http%1
    yd %.part               yd %1
    yd .*-(\S{10,})\.\w+$   _yd https://www.youtube.com/watch?v=%1
    _yd                     youtube-dl

Points to note:

*   the first rule again shows a side-effect being used (change directory);
    notice that the replacement is the same as the pattern so the actual
    command does not change.

*   if an argument starting with http is seen, the second rule *changes the
    command name* from `yd` to `_yd`.  This is a clever way to *bypass* all
    other rules matching the 'yd' command.

*   a trailing ".part" is removed from the argument in the 3rd rule.  This is
    the kind of thing where the idea of step-by-step morphing a command rule
    becomes really intuitive.

*   and finally, the 4th rule gets the juicy bit (the 10-character youtube
    "id") from the file name, constructs a URL from it, and (like rule 2)
    changes the command name to `_yd`.  In spirit, this isn't much different
    from rule 3, just that the expression is a bit more complex.

Why couldn't we remove rule 5 and simply use 'youtube-dl' in rules 2 and 4?
We could, but if we want to add any default arguments etc., later, we'd need
to add them in two places.

Try that in any shell :)

# details

## rc files {#rcfiles}

The program picks up rc files in the following order.  The combined content of
all of them is what is used:

1.  `.__rc` from the same directory (typically something in the PATH) where
    `__` itself is installed.
2.  `.__rc` in the current directory, if it exists.
3.  `.__rc` in its parent directory, if it exists, and so on for each
    successive parent directory, all the way upto \$HOME.

Note that this allows directory-specific aliases -- aliases that would only
apply in a specific directory (or underneath it).  For example, I have several
aliases that are really only applicable to my gitolite development and testing
tasks, so they live in a `.__rc` file in the gitolite source directory.

SECURITY NOTE: If your current directory is not \$HOME (say your PWD is /tmp
or something), then this will behave as if you were in \$HOME (i.e., it will
*never* look for rc files outside your home directory tree).

## rc rule syntax and how it all works {#syn}

Each rule has 3 parts: a pattern, a replacement, and an optional "condition".

The correct syntax for each rule is:

    pattern
        replacement command (shell)
        (optional: more lines of replacement command)
        ...
        ...
        ?   condition code (perl)
            (optional: more lines of condition code)

If the patterns and replacements are short enough for comfortable editing, you
can put them on the same line, using a **hard tab** as the delimitor.  This is
what you see in most of the examples above.

The condition code can also go in as (yet another) tab-delimited field if you
wish, especially if the code is a short snippet.

At the beginning, the program has a notion of the **current command** being
processed.  As each rc rule is read, this current command may be replaced by
("morph into") something else.  When *all* the rules have been read and
processed, whatever remains is executed as a shell command.

Here's some more detail about the 3 fields:

1.  The "pattern" is what the current command is matched against.  If it
    doesn't match, the rule is skipped.  The field is a perl regex, and may
    contain parenthesised sub-expressions.  @@gray((Any regular expression
    tutorial will help you with that if needed))@@.

    It usually contains one or more `%` and/or `%%` signs.  A `%` matches a
    series of non-space characters, while `%%` a series of any characters.
    They are both considered parenthesised sub-expressions; you don't have to
    put them in parentheses.

    The pattern need not match the entire current command unless it ends with
    a `$`.  Only the part of the "current command" that matches this pattern
    will be morphed.  The rest will stay as-is.  (There's an example of this
    above.)

2.  The "replacement" field is the new (morphed) command.  Variables like %1
    and %2 etc.  are replaced by the corresponding matched subgroups in the
    regex match in the previous step.

    This only happens if there is either no "condition" field (see next
    bullet), or there is one and it evaluates to true.  If a "cond" field
    exists and evaluates to false, the morphing is skipped and the next rule
    is checked.

    As you can see, this means a command may potentially be changed multiple
    times before reaching the end of all the rc lines and being executed.

3.  The "condition" field is *optional* code that is evaluated as a perl
    expression.  It may also contain variables like %1 and %2, which are
    replaced by corresponding matched subgroups, before the expression is
    evaluated.

    The expression is evaluated in the context of the main `__` program, and
    it can use global and environment variables to save data and reuse it in
    later steps.  It can also do persistent actions like changing the current
    directory, etc.

## invocation {#inv}

You can invoke `__` in the following ways:

1.  for commands that you use frequently, setup aliases like this:

        alias foo='__ foo'

    Don't worry; this won't recurse forever, assuming foo is originally an
    executable program of some kind (i.e., not a shell builtin, shell
    function, or alias)

2.  for commands that you use rarely, run it explicitly if you want "active
    alias" support.  For example, this will run vlc on the last updated file
    in the current directory.  (See example 4 below for details).

        __ vlc LF

3.  use the "unknown command helper" feature of bash or zsh.  This helps you
    create new aliases by adding them directly into the rc lines for the
    `__` program.

    When you run the command, the shell runs the "unknown command helper"
    (since it can't find such a command, alias, or function), which then runs
    `__` appropriately.  See appendix 1 for the code for this function.

    It's worth repeating that this makes it possible to use pretty much
    **anything** as an implicit alias simply by putting it in this file.
    However, should a real command of that name ever get installed by some
    means, you may have a bit of a confusing time until you realise what
    happened.  At that point, the best thing is to go to method 1 or 2,
    depending on how frequent your use of it is.

## installation

Just put it in your path somewhere.

# appendix 1 -- unknown command helper code

Here's the code.  Note that on bash the function should be called
`command_not_found_handle` (yes -- one letter at the end dropped!)

    command_not_found_handler() {
        if grep >/dev/null "^$1	" `which __`
        then
            __ "$@"
            exit $?
        fi
        unset -f command_not_found_handler      # XXX do we need this?
        exec $SHELL -c "$@"
            # punt to shell.  Note that this is one SHLVL down in zsh
    }
