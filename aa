#!/usr/bin/perl
use strict;
use warnings;
use 5.10.0;
use Data::Dumper;

$Data::Dumper::Indent = 0;
$Data::Dumper::Terse = 1;
$Data::Dumper::Useqq = 1;

sub trace;
my %share;
my @queue;
# the queue is one of the fundamental differences between this version of
# active aliases and the previous one.  It basically allows one command to
# spawn multiple commands as it is processed.  Yes it's useful.  I think :)

setup();
# deal with @ARGV, decide what rc files to use, and set up the queue

while (@queue) {
    dequeue();
}

# ----------------------------------------------------------------------

sub dequeue {
    my @cmd   = @{ shift(@queue) };
    my @lines = @{ shift(@queue) };
    trace "dequeue: ", scalar(@lines), " lines, ", Dumper \@cmd;
    # my @cmd = @{ +shift };
    # my @lines = @{ +shift };

    while (my $line = nextline('patt', \@lines)) {
        last if /__END__/;
        chomp($line);

        # match the current "pattern" line to the current command
        my $res = match($line, @cmd);
        if ($res) {
            trace "pass: $line matches ", Dumper \@cmd;

            # if the match succeeded, you get back a "tail", which is the list
            # of arguments left over after the command matched the pattern
            # (typically, a list of files to be processed), and a list of
            # strings from matched "capture groups" in the pattern
            my @tail = @{ $res->[0] };
            my @groups = @{ $res->[1] };
            trace "cmd, tail, groups = ", Dumper \@cmd, \@tail, \@groups;

            my @subqueue = ();
            # the purpose of the subqueue is that we push commands to it as
            # they get queued while we process the command block, then we
            # *unshift* the whole subqueue to the (front of) the main queue.
            # Otherwise you get queueing inversions (e.g. q t1, q t2, but t1
            # is actually t1a, t1b, t1c, and they all get queued, which means
            # t2 runs before t1a/b/c)

            # now grab the "body", which is the optional "condition" (block of
            # perl code in a single string), and the list of (one or more)
            # commands to run and/or replace the current one, but only if the
            # first block returned true on eval (or was empty).
            my $ccr = nextline('blocks', \@lines);    # cond + commands/replacement
            trace "ccr: ", Dumper $ccr;

            %share = ( 'cmd' => \@cmd, 'tail' => \@tail, 'groups' => \@groups );
            sub grab {
                # allows the perl block to grab stuff from the current lexical scope
                return @{ $share{shift()} };
            }

            # evaluate the condition, if it is present; bail if it returns false
            if ($ccr->[0]) {
                my $res = _eval($ccr->[0], @groups);
                next unless $res;
                $groups[0] = $res;  # the "dummy" slot can now be used!
            }

            # and now the commands...
            my @commands = @{ $ccr->[1] };

            # if the first command is a "meta" command, then all of them have to be
            if ($commands[0] =~ /^%[a-z]+ /) {
                for my $mc (@commands) {
                    # interpolate before sending the line off to meta()
                    $mc = interpolate($mc, \@groups, \@tail);

                    @cmd = meta($mc, \@cmd, \@tail);
                }

                # some metas, like %shell, do not have a "final" command for
                # us to continue processing, so just get out of dequeue
                return unless @cmd;

                # all other cases, we continue transforming the current @cmd
                next;   # get out of this loop
            }

            # now they are either commands to replace the current command (and
            # thus continue being processed by the rest of the rc lines), or
            # -- if the first character is a "!" -- a command to be executed
            # immediately.
            for my $sc (@commands) {
                my @newcmd = interpolate([ split(' ', $sc) ], \@groups, \@tail);

                if ($newcmd[0] eq '!') {
                    shift @newcmd;
                    _system(@newcmd);
                } else {
                    # "processed by the rest of the rc lines" actually means
                    # we add to the queue; see comments on 'queue' at the top.
                    push @subqueue, [ @newcmd ];
                }
            }

            unshift @queue, $_, [ @lines ] for reverse @subqueue;
            return;
        }
    }

    # what's left in @cmd at this point is what we need to run; this is *some*
    # queued command that made it all the way through the remaining lines,
    # without getting transformed.
    trace "final: ", Dumper \@cmd;
    _system(@cmd);
}

# match the current pattern with the current @cmd.  Returns an empty array if
# match fails, otherwise [ \@tail, \@groups ], where @tail is the part of @cmd
# that did not get used up in matching with the pattern, and @groups is the
# combined list of matched sub-expressions from all the capture groups,
# including those representing a "%" (a whole word to be captured)
sub match {
    my $patt = shift;
    my @cmd = @_;

    my @patt = split ' ', $patt;
    my @groups = qw(dummy);
    # start with a dummy so indexing of the actual matched groups can be 1-based

    # first, a "%" all by itself in @patt is syntactic sugar for a single word
    map { $_ = '(.*)' if $_ eq '%' } @patt;

    # matching: the left side is the current command, right side is the
    # pattern.  Go through them item by item (or "word by word", if you will)

    while (@cmd and @patt) {
        my $l = shift @cmd;
        my $r = shift @patt;

        # the purpose of "@" (which can only occur as the last word in a
        # command) is to signify that a tail is **expected**.  It's kinda like
        # a positive lookahead in regex, since it does not consume the
        # corresponding word from the command (because we unshift it back)
        if ($r eq '@') {
            die "'@' must be the last item in pattern\n" if @patt;
            unshift @cmd, $l;
            last;   # @patt should be empty and @cmd, what's left of it, will be @tail
        }

        my $rp = qr(^$r$);

        if ($l eq $r) {
            # do nothing
        } elsif ($l =~ /$rp/) {
            # redo match in list context
            my @g = ($l =~ /$rp/);
            # @g = () if (@g == 1 and $g[0] eq "1"); # no parens; perl returns qw(1)
            # push the matched capture groups into @groups
            push @groups, @g if @g;

        } elsif ($r eq '%%') {
            # try to match a '%%' in the @patt with as many words from @cmd as
            # you can
            my $i = 0;
            unshift @cmd, $l;
            if (! @patt) {
                # that %% was the last token; all of @cmd matches
                push @groups, [ @cmd ];
                @cmd = ();
                last;
            }
            my $p = $patt[0];   # the next word in the pattern, after the "%%" we're at
            while ($i < @cmd) {
                last if $cmd[$i] eq $p or $cmd[$i] =~ /$p/;
                $i++;
            }
            if ($i < @cmd) {
                # since a single %% can match more than one word in @cmd, we
                # push them into @groups as a ref of an array rather than a
                # single scalar value.
                push @groups, [ @cmd[ 0..$i-1 ] ];
                splice(@cmd, 0, $i);
            } else {
                return ()
            }

        } else {
            return ();
        }
    }

    # more of the pattern exists, but our current @cmd ran out, so clearly
    # this is not a match
    return () if @patt;

    return [ \@cmd, \@groups ];
}

# ----------------------------------------------------------------------
# meta, interpolate, and shemulate -- all of these have to do with munging the
# command+arguments in some way

# meta commands in the rc file are special "escape" routines to do more
# complex things that cannot be done directly in the user's rc file.
sub meta {
    my $mc = shift;
    my @cmd = @{ shift() };
    my @tail = @{ shift() };

    trace "meta: mc = $mc";

    # "%shell <shell command>" runs the command supplied as a shell command.
    # This is potentially dangerous if the files have shell-unsafe names, but
    # sometimes you gotta do what you gotta do!  (TBD: interpolate() may need
    # to quote each member of tail before joining, which may be hard.  Best
    # use this only for safe filenames, and for others, use a wrapper!
    if ($mc =~ /^%shell +(.*)/) {
        my $sc = $1;

        trace "shell ", Dumper $sc;
        _system("sh", "-c", $sc);
        return ();
    }

    # "%args <prefix> `<expr>`" runs the expr as a shell command, captures the
    # output, and uses that as the new argument list (new-line separated, not
    # space separated; i.e., one argument per line).  NOTE: you should not
    # have anything *after* the expression.
    if ($mc =~ /^%args +(.*?) +`(.*)`/) {
        my $prefix = $1;
        my $expr = $2;

        my @args = `$expr`;
        chomp(@args);
        trace "args: ", Dumper \@args;
        return (split(' ', $prefix), @args);
    }

    die "not a valid meta command";
}

# emulate shell, poorly :-)  Just $$, $var, ${var}, and "~/" are handled
sub shemulate {
    my @a = @_;
    map { s(\$\$)($$)g } @a;
    map { s(^~/)($ENV{HOME}/) } @a;
    map { s(\$(\w+))($ENV{$1})g } @a;
    map { s(\$\{(\w+)\})($ENV{$1})g } @a;
    # NOTE: warn in documentation that complex stuff (like, say "${var:-val}
    # etc won't work; we're not a shell!

    return @a;
}

# interpolate %1, %2, etc using matched groups found from match().  note that
# some calls do not supply a tail at all, so you need to check for that too
sub interpolate {
    my ($cmd, $groups, $tail) = @_;

    # allow passing in a string to be interpolated, as opposed to an array
    if (not ref($cmd)) {
        my @cmd = interpolate([ split(' ', $cmd) ], $groups, $tail);
        return join(" ", @cmd);
    }

    # a %. at the end says "don't attach the tail to me please!"
    if ($cmd->[-1] eq '%.') {
        pop @$cmd;
        undef $tail;
    }

    my @ret;
    for my $w (map $_, @$cmd) {
        if ($w =~ /^%(\d+)$/) {
            $w = $groups->[$1];
            if (ref($w)) {
                # result of matching "%%" is a list-ref; expand it and push
                push @ret, @$w;
            } else {
                push @ret, $w;
            }
        } elsif ($w eq '%@') {
            # explicit positioning of the tail.  Logical conflict with %., but
            # at the moment we don't detect/warn if both are used.
            push @ret, @$tail;
            undef $tail;
        } else {
            $w =~ s/%(\d+)/$groups->[$1]/g;
            $tail and ref($tail) and $w =~ s/%@/join(" ", @$tail)/ge and undef $tail;
            push @ret, $w;
        }
    }

    # otherwise, by default, attach the tail (if it exists) at the end
    push @ret, @$tail if $tail and ref($tail);

    return @ret;
}

sub setup {
    die "Usage: $0 command [args]\n" unless @ARGV;
    @ARGV = qw(_commands) if @ARGV == 1 and $ARGV[0] eq '-h';

    # treat newlines embedded in arguments as argument separators.  This lets
    # you operate on file lists, such as the output of "`find ...`" (note the
    # double quotes).
    @ARGV = split("\n", join("\n", @ARGV));

    # the queue always contains an even number of entries, the first a ref to
    # the current command, and the second a ref to a list of rc lines to be
    # processed.  The first pair comes from the command line arguments and the
    # entire contents of the rc files.  During processing of this pair, more
    # pairs can be pushed to the end of the queue (but it will eventually run
    # out, not to worry!)
    push @queue, [ @ARGV ];     # this becomes the initial command

    # ----------------------------------------------------------------------
    # what rc file do we use?

    if ($ENV{AA_RC} and -f $ENV{AA_RC}) {
        @ARGV = ($ENV{AA_RC});  # only the one file in this case
    } else {
        @ARGV = ();
        # first, the one from the current directory, but only if it is within $HOME
        push @ARGV, "$ENV{PWD}/.aarc" if $ENV{PWD} ne $ENV{HOME}
                              and !index($ENV{PWD},   $ENV{HOME})
                                 and -f "$ENV{PWD}/.aarc";
        # next, the one in ~, and then the one in ~/.config (note the latter
        # one is called "aarc" not ".aarc")
        push @ARGV, grep { -f } ( "$ENV{HOME}/.aarc", "$ENV{HOME}/.config/aarc" );
        # the overall idea is that the one in ~/.config will be on all your
        # machines (if you have a "dot file" git repo, for instance, it will
        # have this), and the one in your ~ will be specific to this user (for
        # example user versus root, or if, like me, you use different userids
        # for different tasks)
    }

    my @lines = <>;     # which, as you know, eats up @ARGV;
    push @queue, \@lines;

    # check if shell completion command requested
    _commands();    # this does not return; exits after doing its thing

    # ----------------------------------------------------------------------
    # setup some env vars and such, for convenience

    $ENV{_tty} = ( -t ? 1 : 0 );

}

sub _commands {
    my @cmd  = @{ $queue[0] };
    return unless @cmd == 1 and $cmd[0] eq '_commands';
    my $lines = $queue[1];
    for (@$lines) {
        print if s/^## (\w+:)/$1/;
    }

    exit 0;
}

# ----------------------------------------------------------------------
# routines at the next lower level of abstraction

# return the next logical line.  When called with 'patt' as the argument,
# return the next pattern line.  When called with 'blocks', return the
# conditional block, if any, as a single string, followed by the command block
# (as a reference to the list of commands to run)
sub nextline {
    my $want = shift;
    my $lines =shift;
    while (@$lines) {
        if ($want eq 'patt') {
            $_ = get($lines);
            redo if /^\s/;  # code block lines from a failed pattern; skip
            return $_;      # line starts with \S
        }

        # that leaves $want eq 'blocks'

        my $cond = '';
        my @newcmd = '';

        $_ = get($lines);

        if (s/^    \?   //) {
            $cond = $_;
            while ($_ = get($lines)) {
                last unless s/^        //;
                $cond .= $_;
            }
        }

        if (s/^    //) {
            @newcmd = ($_);
            while ($_ = get($lines)) {
                last unless s/^    //;
                chomp;
                push @newcmd, $_;
            }
        }

        unget($_, $lines);

        return [ $cond, \@newcmd ];
    }
}

# just a perl eval, but first interpolate() groups found earlier by match()
sub _eval {
    my $e = shift;      # expression
    # that leaves @groups in @_

    # wrap $e in an array (and unwrap the result) because interpolate will do
    # nasty things to perl code if you send in a string!
    $e = (interpolate([$e], \@_))[0];

    trace "eval: $e";
    my $rc = eval $e;
    say STDERR "eval failed; $@" unless defined($rc);
    return $rc;
}

# ----------------------------------------------------------------------
# general purpose routines

sub get {
    my $lines = shift;
    return "" unless @$lines;
    my $r = shift @$lines;
    while ($r =~ /^\s*#/ or $r =~ /^\s*$/) {
        return "" unless @$lines;
        $r = shift @$lines;
    }

    # support old syntax, at least for pattern+replacement (not pattern+replacement+condition)
    if ($r =~ /(.*)\t(.*)/) {
        unshift @$lines, "    $2";
        $r = $1;
    }

    return $r;
}
sub unget {
    my $l = shift;
    my $lines = shift;
    unshift @$lines, $l;
}

# run a command, but first shemulate()
sub _system {
    @_ = shemulate(@_) unless @_ > 2 and $_[0] eq 'sh' and $_[1] eq '-c';
    if ($_[0] eq '+') {
        shift @_;
        say STDERR join(" ", "+", @_);
    }

    # run system(), catch errors.  Be verbose only if $ENV{D} exists.  If not,
    # exit with <rc of system()> if it applies, else just "exit 1".

    my $rc;
    if ($_[0] eq 'exec') {
        # XXX warn in docs about any subsequent queued items going bye-bye!
        # (Or better yet, since the @queue is file scoped, detect if there are
        # more commands and warn the user!
        shift;
        $rc = exec(@_);
    } else {
        $rc = system(@_);
    }

    if ( $rc != 0 ) {
        say STDERR "system() failed: ", join(" ", @_), " -> $?";
        if ( $? == -1 ) {
            die "failed to execute: $!\n" if $ENV{D};
        } elsif ( $? & 127 ) {
            die "child died with signal " . ( $? & 127 ) . "\n" if $ENV{D};
        } else {
            die "child exited with value " . ( $? >> 8 ) . "\n" if $ENV{D};
            exit( $? >> 8 );
        }
        exit 1;
    }
}

sub trace {
    return unless $ENV{D};
    say STDERR "[$$] ", @_;
}

__END__

to be tested
    %0 as a replacement for perl block output
    perl block sending out a complete @cmd
    %% in all its glory
    use %% to implement LC, FN, etc -- MUST BE SIMPLE!!!
