#!/usr/bin/perl
# TODO:
#   help system
#   should we use the cond result in the command as %?
#   finish the documentation, including translating all the examples to the new syntax
use strict;
use warnings;
use 5.10.0;
use Data::Dumper;

$Data::Dumper::Indent = 0;
$Data::Dumper::Terse = 1;
$Data::Dumper::Useqq = 1;

sub trace;
my %share;
my @queue;
# the queue is one of the fundamental differences between this version of
# active aliases and the previous one.  It basically allows one command to
# spawn multiple commands as it is processed.  Yes it's useful.  I think :)

setup();
# deal with @ARGV, decide what rc files to use, and set up the queue

while (@queue) {
    dequeue();
}

# ----------------------------------------------------------------------

sub dequeue {
    my @cmd   = @{ shift(@queue) };
    my @lines = @{ shift(@queue) };
    trace "dequeue: ", scalar(@lines), " lines, ", Dumper \@cmd;
    # my @cmd = @{ +shift };
    # my @lines = @{ +shift };

    while (my $line = nextline('patt', \@lines)) {
        last if /__END__/;
        chomp($line);

        # match the current "pattern" line to the current command
        my $res = match($line, @cmd);
        if ($res) {
            trace "pass: $line matches ", Dumper \@cmd;

            # if the match succeeded, you get back a "tail", which is the list
            # of arguments left over after the command matched the pattern
            # (typically, a list of files to be processed), and a list of
            # strings from matched "capture groups" in the pattern
            my @tail = @{ $res->[0] };
            my @groups = @{ $res->[1] };
            trace "cmd, tail, groups = ", Dumper \@cmd, \@tail, \@groups;

            my @subqueue = ();
            # the purpose of the subqueue is that we push commands to it as
            # they get queued while we process the command block, then we
            # *unshift* the whole subqueue to the (front of) the main queue.
            # Otherwise you get queueing inversions (e.g. q t1, q t2, but t1
            # is actually t1a, t1b, t1c, and they all get queued, which means
            # t2 runs before t1a/b/c)

            # now grab the "body", which is the optional "condition" (block of
            # perl code in a single string), and the list of (one or more)
            # commands to run and/or replace the current one, but only if the
            # first block returned true on eval (or was empty).
            my $ccr = nextline('blocks', \@lines);    # cond + commands/replacement
            trace "ccr: ", Dumper $ccr;

            %share = ( 'cmd' => \@cmd, 'tail' => \@tail, 'groups' => \@groups );
            sub grab {
                # allows the perl block to grab stuff from the current lexical scope
                return @{ $share{shift()} };
            }

            # evaluate the condition, if it is present; bail if it returns false
            if ($ccr->[0]) {
                my $res = _eval($ccr->[0], @groups);
                next unless $res;
            }

            # and now the commands...
            my @commands = @{ $ccr->[1] };

            # if the first command is a "meta" command, then all of them have to be
            if ($commands[0] =~ /^%[a-z]+ /) {
                for my $mc (@commands) {
                    # interpolate before sending the line off to meta().
                    # Except for %s, which has/needs its own internal one
                    $mc = interpolate($mc, @groups) unless $mc =~ /^%s /;

                    @cmd = meta($mc, \@cmd, \@tail, \@subqueue);
                }

                # some metas (like %each) would have added to the subqueue.
                # Add each of those commands to the main queue, along with the
                # required @lines ref.
                unshift @queue, $_, [ @lines ] for reverse @subqueue;

                # some metas, like %each and %shell, do not have a "final"
                # command for us to continue processing (%each would have
                # queued up other commands, and %shell would have actually
                # *run* some commands).  For those, we just get out of dequeue
                return unless @cmd;

                # all other cases, we continue transforming the current @cmd
                next;   # get out of this loop
            }

            # now they are either commands to replace the current command (and
            # thus continue being processed by the rest of the rc lines), or
            # -- if the first character is a "!" -- a command to be executed
            # immediately.
            for my $sc (@commands) {
                if (0) {
                    # TBD; deal with "!"
                    run_now($sc, \@tail, @groups);
                } else {
                    # "processed by the rest of the rc lines" actually means
                    # we add to the queue; see comments on 'queue' at the top.
                    my @newcmd = split(' ', $sc);
                    for my $c (@newcmd) {
                        $c = interpolate($c, @groups);
                    }

                    # normally, the "tail" (described earlier) is tacked on to
                    # the end of the new command.  However, sometimes a queued
                    # command does not want that; if so, it ends the command
                    # with a "%.", and then the tail won't be added to it.
                    if ($newcmd[-1] eq "%.") {
                        pop @newcmd;
                    } else {
                        push @newcmd, @tail;
                    }

                    push @subqueue, [ @newcmd ];
                }
            }

            unshift @queue, $_, [ @lines ] for reverse @subqueue;
            return;
        }
    }

    # what's left in @cmd at this point is what we need to run; this is *some*
    # queued command that made it all the way through the remaining lines,
    # without getting transformed.
    trace "final: ", Dumper \@cmd;
    _system(@cmd);
}

# match the current pattern with the current @cmd.  Returns an empty array if
# match fails, otherwise [ \@tail, \@groups ], where @tail is the part of @cmd
# that did not get used up in matching with the pattern, and @groups is the
# combined list of matched sub-expressions from all the capture groups,
# including those representing a "%" (a whole word to be captured)
sub match {
    my $patt = shift;
    my @cmd = @_;

    my @patt = split ' ', $patt;
    my @groups = qw(dummy);
    # start with a dummy so indexing of the actual matched groups can be 1-based

    # the left side is the current command, right side is the pattern.  Go
    # through them item by item (or "word by word", if you will)
    while (@cmd and @patt) {
        my $l = shift @cmd;
        my $r = shift @patt;

        # the purpose of "@" (which can only occur as the last word in a
        # command) is to signify that a tail is **expected**.  It's kinda like
        # a positive lookahead in regex, since it does not consume the
        # corresponding word from the command (because we unshift it back)
        if ($r eq '@') {
            die "'@' must be the last item in pattern\n" if @patt;
            unshift @cmd, $l;
            last;   # @patt should be empty and @cmd, what's left of it, will be @tail
        }

        # a "%" is of course a single word
        $r = '(.*)' if $r eq '%';
        my $rp = qr(^$r$);

        if ($l eq $r) {
            # do nothing
        } elsif ($l =~ /$rp/) {
            # redo match in list context
            my @g = ($l =~ /$rp/);
            # @g = () if (@g == 1 and $g[0] eq "1"); # no parens; perl returns qw(1)
            push @groups, @g if @g;
        } else {
            return ();
        }
    }

    # more of the pattern exists, but our current @cmd ran out, so clearly
    # this is not a match
    return () if @patt;

    return [ \@cmd, \@groups ];
}

# ----------------------------------------------------------------------
# meta, interpolate, and shemulate -- all of these have to do with munging the
# command+arguments in some way

# meta commands in the rc file are special "escape" routines to do more
# complex things that cannot be done directly in the user's rc file.
sub meta {
    my $mc = shift;
    my @cmd = @{ shift() };
    my @tail = @{ shift() };
    my $subqueue = shift;

    trace "meta: mc = $mc";

    # "%s <expr> %with <expr>" does pretty much the equivalent of s/foo/bar/,
    # except it is word by word, and the replacement can be more then one
    # word.  Note that @cmd includes @tail, so we don't have to treat tail
    # separately
    if ($mc =~ /^%s (.*) %with (.*)/) {
        my $f = $1;
        my @t = split ' ', $2;
        trace "pre-%s: ", Dumper $mc, $f, \@t;
        trace "pre-%s: ", Dumper \@cmd;

        my @newcmd = ();
        for (@cmd) {
            if (/^$f$/) {
                my @g = (/^$f$/);
                unshift @g, ''; # make it 1-relative for interpolate()
                for my $t (@t) {
                    push @newcmd, interpolate($t, @g);
                }
            } else {
                push @newcmd, $_;
            }
        }

        trace "%s: " . join("|", @newcmd);
        return @newcmd;
    }

    # "%each <command+args>" runs, or rather queues up, the command+args on
    # each of the words in the "tail" (such as a list of files).  Useful when
    # the command can't process multiple files at a time
    if ($mc =~ /^%each (.*)/) {
        my @c = split ' ', $1;
        trace "each: ", Dumper \@c, \@tail;
        for (@tail) {
            push @$subqueue, [ @c, $_ ];
        }
        return ();
    }

    # "%shell <shell command>" runs the command supplied as a shell command.
    # This is potentially dangerous if the files have shell-unsafe names, but
    # sometimes you gotta do what you gotta do!  We also append the tail...
    # (TBD: quote each member of @tail before joining)
    if ($mc =~ /^%shell (.*)/) {
        my $sc = $1;

        # normally, the tail arguments are tacked on to the end.  But some
        # commands may need the list at some other position.  This can be
        # expressed as "%@" if required.  (E.g., where you need the command to
        # run have the tail within quotes; see "vg" in test.aarc)
        if ($sc =~ /(.*)%@(.*)/) {
            $sc = $1 . join(" ", @tail) . $2;
        } else {
            $sc = join(" ", $1, @tail);
        }
        trace "shell ", Dumper $sc;
        _system("sh", "-c", $sc);
        return qw(true);
    }

    # "%args <cmd> <expr>" runs the expr as a shell command, captures the output,
    # and uses that as the new argument list (new-line separated, not space
    # separated; i.e., one argument per line.  Tail handling is same as %shell
    if ($mc =~ /^%args (\S+) (.*)/) {
        my $cmd = $1;
        my $sc = $2;
        if ($sc =~ /(.*)%@(.*)/) {
            $sc = $1 . join(" ", @tail) . $2;
        } else {
            $sc = join(" ", $sc, @tail);
        }

        my @args = `$sc`;
        chomp(@args);
        trace "args: ", Dumper \@args;
        return ($cmd, @args);
    }

    # # XXX DO NOT USE UNTIL WE ARE SURE IT IS REALLY NEEDED XXX
    # # "%map <expr>" evaluates the perl expr for each word in the current
    # # command and replace with the result
    # if ($mc =~ /^%map (.*)/) {
    #     my $e = $1;
    #     @cmd = map { eval $e } @cmd;
    #     # # for (@cmd) {
    #     # #     my $rc = eval $e;
    #     # #     die $@ unless defined($rc);
    #     # # }
    #     trace "post-map: ", Dumper \@cmd;
    #     return @cmd;
    # }

    die "not a valid meta command";
}

# emulate shell, poorly :-)  Just $$, $var, ${var}, and "~/" are handled
sub shemulate {
    my @a = @_;
    map { s(\$\$)($$)g } @a;
    map { s(^~/)($ENV{HOME}/) } @a;
    map { s(\$(\w+))($ENV{$1})g } @a;
    map { s(\$\{(\w+)\})($ENV{$1})g } @a;
    # NOTE: warn in documentation that complex stuff (like, say "${var:-val}
    # etc won't work; we're not a shell!

    return @a;
}

# interpolate %1, %2, etc using matched groups found from match()
sub interpolate {
    my $c = shift;
    # that leaves @groups in @_;  (and remember its first element is a dummy,
    # to make 1-based indexing work for us)
    $c =~ s/%(\d+)/$_[$1]/gm;
    $c;
}

sub setup {
    die "Usage: $0 command [args]\n" unless @ARGV;

    # if the first character of the first word in the command is a dash, we
    # have to remove it (see documentation); this allows you to trivially
    # override real commands and force them to go through active-aliases
    $ARGV[0] =~ s/^-//;

    # treat newlines embedded in arguments as argument separators.  This lets
    # you operate on file lists, such as the output of "`find ...`" (note the
    # double quotes).
    @ARGV = split("\n", join("\n", @ARGV));

    # the queue always contains an even number of entries, the first a ref to
    # the current command, and the second a ref to a list of rc lines to be
    # processed.  The first pair comes from the command line arguments and the
    # entire contents of the rc files.  During processing of this pair, more
    # pairs can be pushed to the end of the queue (but it will eventually run
    # out, not to worry!)
    push @queue, [ @ARGV ];     # this becomes the initial command

    # ----------------------------------------------------------------------
    # what rc file do we use?

    if ($ENV{AA_RC} and -f $ENV{AA_RC}) {
        @ARGV = ($ENV{AA_RC});  # only the one file in this case
    } else {
        @ARGV = ();
        # first, the one from the current directory, but only if it is within $HOME
        push @ARGV, "$ENV{PWD}/.aarc" if $ENV{PWD} ne $ENV{HOME}
                              and !index($ENV{PWD},   $ENV{HOME})
                                 and -f "$ENV{PWD}/.aarc";
        # next, the one in ~, and then the one in ~/.config (note the latter
        # one is called "aarc" not ".aarc")
        push @ARGV, grep { -f } ( "$ENV{HOME}/.aarc", "$ENV{HOME}/.config/aarc" );
        # the overall idea is that the one in ~/.config will be on all your
        # machines (if you have a "dot file" git repo, for instance, it will
        # have this), and the one in your ~ will be specific to this user (for
        # example user versus root, or if, like me, you use different userids
        # for different tasks)
    }

    my @lines = <>;     # which, as you know, eats up @ARGV;
    push @queue, \@lines;

    # check if shell completion command requested
    _commands();    # this does not return; exits after doing its thing

    # ----------------------------------------------------------------------
    # setup some env vars and such, for convenience

    $ENV{_tty} = ( -t ? 1 : 0 );

}

sub _commands {
    my @cmd  = @{ $queue[0] };
    return unless @cmd == 1 and $cmd[0] eq '_commands';
    my $lines = $queue[1];
    for (@$lines) {
        print if s/^## (\w+:)/$1/;
    }

    exit 0;
}

# ----------------------------------------------------------------------
# routines at the next lower level of abstraction

# return the next logical line.  When called with 'patt' as the argument,
# return the next pattern line.  When called with 'blocks', return the
# conditional block, if any, as a single string, followed by the command block
# (as a reference to the list of commands to run)
sub nextline {
    my $want = shift;
    my $lines =shift;
    while (@$lines) {
        if ($want eq 'patt') {
            $_ = get($lines);
            redo if /^\s/;  # code block lines from a failed pattern; skip
            return $_;      # line starts with \S
        }

        # that leaves $want eq 'blocks'

        my $cond = '';
        my @newcmd = '';

        $_ = get($lines);

        if (s/^    \?   //) {
            $cond = $_;
            while ($_ = get($lines)) {
                last unless s/^        //;
                $cond .= $_;
            }
        }

        if (s/^    //) {
            @newcmd = ($_);
            while ($_ = get($lines)) {
                last unless s/^    //;
                chomp;
                push @newcmd, $_;
            }
        }

        unget($_, $lines);

        return [ $cond, \@newcmd ];
    }
}

# just a perl eval, but first interpolate() groups found earlier by match()
sub _eval {
    my $e = shift;      # expression
    # that leaves @groups in @_

    $e = interpolate($e, @_);

    trace "eval: $e";
    my $rc = eval $e;
    say STDERR "eval failed; $@" unless defined($rc);
    return $rc;
}

# system to run a command, but first interpolate(), because where this is
# called, interpolate() has not happened
sub run_now {
    my $c = shift;
    my $tail = shift;
    # that leaves @groups in @_

    my @c = split(' ', $c);
    for my $c (@c) {
        $c = interpolate($c, @_);
    }

    trace "run: ", Dumper \@c, $tail;
    _system(@c, @$tail);
}

# ----------------------------------------------------------------------
# general purpose routines

sub get {
    my $lines = shift;
    return "" unless @$lines;
    my $r = shift @$lines;
    while ($r =~ /^\s*#/ or $r =~ /^\s*$/) {
        return "" unless @$lines;
        $r = shift @$lines;
    }
    return $r;
}
sub unget {
    my $l = shift;
    my $lines = shift;
    unshift @$lines, $l;
}

# run a command, but first shemulate()
sub _system {
    @_ = shemulate(@_) unless @_ > 2 and $_[0] eq 'sh' and $_[1] eq '-c';
    if ($_[0] eq '+') {
        shift @_;
        say STDERR join(" ", "+", @_);
    }

    # run system(), catch errors.  Be verbose only if $ENV{D} exists.  If not,
    # exit with <rc of system()> if it applies, else just "exit 1".
    if ( system(@_) != 0 ) {
        say STDERR "system() failed: ", join(" ", @_), " -> $?";
        if ( $? == -1 ) {
            die "failed to execute: $!\n" if $ENV{D};
        } elsif ( $? & 127 ) {
            die "child died with signal " . ( $? & 127 ) . "\n" if $ENV{D};
        } else {
            die "child exited with value " . ( $? >> 8 ) . "\n" if $ENV{D};
            exit( $? >> 8 );
        }
        exit 1;
    }
}

sub trace {
    return unless $ENV{D};
    say STDERR "[$$] ", @_;
}
